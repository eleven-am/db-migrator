// Code generated by Storm ORM generator. DO NOT EDIT.
// Generated at: 2025-07-15 12:54:23

package todo

import (
	"context"
	"fmt"
	"github.com/eleven-am/storm/internal/orm"
	"github.com/jmoiron/sqlx"
)

// Storm provides a centralized access point for all repositories
type Storm struct {
	*orm.Storm

	// All repositories

	Categorys *CategoryRepository

	Comments *CommentRepository

	Tags *TagRepository

	Todos *TodoRepository

	TodoTags *TodoTagRepository

	Users *UserRepository

	UserTags *UserTagRepository
}

// NewStorm creates a new Storm instance with all repositories initialized
func NewStorm(db *sqlx.DB) *Storm {
	// Create base Storm
	baseStorm := orm.NewStorm(db)

	// Create our Storm with embedded base
	storm := &Storm{
		Storm: baseStorm,
	}

	// Initialize repositories
	storm.initializeRepositories()

	return storm
}

// WithTransaction executes a function within a database transaction
// It returns a transaction-aware Storm instance to the callback
func (s *Storm) WithTransaction(ctx context.Context, fn func(*Storm) error) error {
	return s.Storm.WithTransaction(ctx, func(baseStorm *orm.Storm) error {
		// Create transaction Storm with same embedded base
		txStorm := &Storm{
			Storm: baseStorm,
		}
		// Initialize repositories with transaction executor
		txStorm.initializeRepositories()
		return fn(txStorm)
	})
}

// WithTransactionOptions executes a function within a database transaction with options
func (s *Storm) WithTransactionOptions(ctx context.Context, opts *orm.TransactionOptions, fn func(*Storm) error) error {
	return s.Storm.WithTransactionOptions(ctx, opts, func(baseStorm *orm.Storm) error {
		// Create transaction Storm with same embedded base
		txStorm := &Storm{
			Storm: baseStorm,
		}
		// Initialize repositories with transaction executor
		txStorm.initializeRepositories()
		return fn(txStorm)
	})
}

// initializeRepositories initializes all repository instances
func (s *Storm) initializeRepositories() {
	executor := s.GetExecutor()

	// Initialize Category repository
	if baseRepo, err := orm.NewRepositoryWithExecutor[Category](executor); err == nil {
		s.Categorys = &CategoryRepository{
			Repository: baseRepo,
		}
	} else {
		panic(fmt.Errorf("failed to initialize Category repository: %w", err))
	}

	// Initialize Comment repository
	if baseRepo, err := orm.NewRepositoryWithExecutor[Comment](executor); err == nil {
		s.Comments = &CommentRepository{
			Repository: baseRepo,
		}
	} else {
		panic(fmt.Errorf("failed to initialize Comment repository: %w", err))
	}

	// Initialize Tag repository
	if baseRepo, err := orm.NewRepositoryWithExecutor[Tag](executor); err == nil {
		s.Tags = &TagRepository{
			Repository: baseRepo,
		}
	} else {
		panic(fmt.Errorf("failed to initialize Tag repository: %w", err))
	}

	// Initialize Todo repository
	if baseRepo, err := orm.NewRepositoryWithExecutor[Todo](executor); err == nil {
		s.Todos = &TodoRepository{
			Repository: baseRepo,
		}
	} else {
		panic(fmt.Errorf("failed to initialize Todo repository: %w", err))
	}

	// Initialize TodoTag repository
	if baseRepo, err := orm.NewRepositoryWithExecutor[TodoTag](executor); err == nil {
		s.TodoTags = &TodoTagRepository{
			Repository: baseRepo,
		}
	} else {
		panic(fmt.Errorf("failed to initialize TodoTag repository: %w", err))
	}

	// Initialize User repository
	if baseRepo, err := orm.NewRepositoryWithExecutor[User](executor); err == nil {
		s.Users = &UserRepository{
			Repository: baseRepo,
		}
	} else {
		panic(fmt.Errorf("failed to initialize User repository: %w", err))
	}

	// Initialize UserTag repository
	if baseRepo, err := orm.NewRepositoryWithExecutor[UserTag](executor); err == nil {
		s.UserTags = &UserTagRepository{
			Repository: baseRepo,
		}
	} else {
		panic(fmt.Errorf("failed to initialize UserTag repository: %w", err))
	}

}
