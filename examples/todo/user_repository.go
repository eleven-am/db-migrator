// Code generated by Storm ORM generator. DO NOT EDIT.
// Generated at: 2025-07-15 12:54:23

package todo

import (
	"context"
	"fmt"
	"github.com/eleven-am/storm/internal/orm"
	"github.com/jmoiron/sqlx"
)

// UserRepository provides type-safe operations for User
type UserRepository struct {
	*orm.Repository[User]
}

// newUserRepository creates a new User repository (internal use only - use Storm)
func newUserRepository(db *sqlx.DB) (*UserRepository, error) {
	baseRepo, err := orm.NewRepository[User](db)
	if err != nil {
		return nil, fmt.Errorf("failed to create base repository: %w", err)
	}

	return &UserRepository{
		Repository: baseRepo,
	}, nil
}

// newUserRepositoryWithTx creates a new User repository using an existing transaction (internal use only - use Storm)
func newUserRepositoryWithTx(tx *sqlx.Tx) (*UserRepository, error) {
	baseRepo, err := orm.NewRepositoryWithTx[User](tx)
	if err != nil {
		return nil, fmt.Errorf("failed to create base repository with transaction: %w", err)
	}

	return &UserRepository{
		Repository: baseRepo,
	}, nil
}

// Query returns a type-safe query builder for User
func (r *UserRepository) Query() *UserQuery {
	return &UserQuery{
		Query: r.Repository.Query(),
		repo:  r,
	}
}

// QueryContext returns a type-safe query builder for User with context
func (r *UserRepository) QueryContext(ctx context.Context) *UserQuery {
	return &UserQuery{
		Query: r.Repository.QueryContext(ctx),
		repo:  r,
	}
}

// WithTodos includes the Todos relationship in queries
func (r *UserRepository) WithTodos() *UserQuery {
	return &UserQuery{
		Query: r.Repository.Query().Include("Todos"),
		repo:  r,
	}
}

// WithCategories includes the Categories relationship in queries
func (r *UserRepository) WithCategories() *UserQuery {
	return &UserQuery{
		Query: r.Repository.Query().Include("Categories"),
		repo:  r,
	}
}

// WithTags includes the Tags relationship in queries
func (r *UserRepository) WithTags() *UserQuery {
	return &UserQuery{
		Query: r.Repository.Query().Include("Tags"),
		repo:  r,
	}
}

// Domain-specific finder methods

// FindByEmail finds a User by Email
func (r *UserRepository) FindByEmail(ctx context.Context, value string) (*User, error) {
	return r.QueryContext(ctx).Where(Users.Email.Eq(value)).First()
}

// FindWhereIsActive finds User records where IsActive is true/false
func (r *UserRepository) FindWhereIsActive(ctx context.Context, value bool) ([]User, error) {
	return r.QueryContext(ctx).Where(Users.IsActive.Eq(value)).Find()
}

// FindByIDLike finds User records where ID matches pattern
func (r *UserRepository) FindByIDLike(ctx context.Context, pattern string) ([]User, error) {
	return r.QueryContext(ctx).Where(Users.ID.Like(pattern)).Find()
}

// FindByEmailLike finds User records where Email matches pattern
func (r *UserRepository) FindByEmailLike(ctx context.Context, pattern string) ([]User, error) {
	return r.QueryContext(ctx).Where(Users.Email.Like(pattern)).Find()
}

// FindByNameLike finds User records where Name matches pattern
func (r *UserRepository) FindByNameLike(ctx context.Context, pattern string) ([]User, error) {
	return r.QueryContext(ctx).Where(Users.Name.Like(pattern)).Find()
}

// FindByPasswordLike finds User records where Password matches pattern
func (r *UserRepository) FindByPasswordLike(ctx context.Context, pattern string) ([]User, error) {
	return r.QueryContext(ctx).Where(Users.Password.Like(pattern)).Find()
}

// Batch operations (available methods from base repository)
// - UpsertMany: bulk upsert with ON CONFLICT resolution
// - BulkUpdate: update multiple records with different values
// Usage examples:
//   repo.UpsertMany(records, orm.UpsertOptions{ConflictColumns: []string{"id"}})
//   repo.BulkUpdate(records, orm.BulkUpdateOptions{})
