//go:build !exclude_generated
// +build !exclude_generated

// Code generated by storm orm generate-orm; DO NOT EDIT.
//
// This file was automatically generated from Go struct definitions.
// Any changes made to this file will be lost when regenerating.
//
// Source package: todo
// Model: User
// Generated on: 2025-07-17 00:36:07 CEST
//
// To regenerate this file, run:
//   storm orm generate-orm --package=todo
//
// For more information, see:
//   https://github.com/eleven-am/storm

package todo

import (
	"context"
	"fmt"
	"github.com/eleven-am/storm/internal/orm"
	"github.com/jmoiron/sqlx"
)

// UserRepository provides type-safe operations for User
//
// The repository inherits these operations from orm.Repository:
//
// Single Record Operations:
//   - Create(ctx, record) - Insert single record
//   - FindByID(ctx, id) - Find record by primary key
//   - Update(ctx, record) - Update single record by primary key
//   - Delete(ctx, id) - Delete record by primary key ID
//   - DeleteRecord(ctx, record) - Delete record using the record instance
//
// Batch Operations:
//   - CreateMany(ctx, records) - Insert multiple records in transaction
//   - UpdateMany(ctx, updates, condition) - Update multiple records with condition
//   - BulkUpdate(ctx, records, opts) - Bulk update using CTE with VALUES
//   - Upsert(ctx, record, opts) - Insert or update on conflict
//   - UpsertMany(ctx, records, opts) - Batch upsert operations
//
// Query Building:
//   - Query() - Create new query builder for complex queries
//   - QueryContext(ctx) - Create query builder with context support
//
// Example usage:
//
//	// Single operations
//	user, err := repo.FindByID(ctx, "123")
//	err = repo.Create(ctx, &newUser)
//
//	// Batch operations
//	err = repo.CreateMany(ctx, multipleUsers)
//	rowsAffected, err := repo.UpdateMany(ctx, updates, condition)
//
//	// Complex queries
//	results, err := repo.Query().Where(condition).OrderBy("created_at DESC").Find()
type UserRepository struct {
	*orm.Repository[User]
}

func newUserRepository(db *sqlx.DB) (*UserRepository, error) {
	baseRepo, err := orm.NewRepository[User](db, UserMetadata)
	if err != nil {
		return nil, fmt.Errorf("failed to create base repository: %w", err)
	}

	return &UserRepository{
		Repository: baseRepo,
	}, nil
}

func newUserRepositoryWithTx(tx *sqlx.Tx) (*UserRepository, error) {
	baseRepo, err := orm.NewRepositoryWithTx[User](tx, UserMetadata)
	if err != nil {
		return nil, fmt.Errorf("failed to create base repository with transaction: %w", err)
	}

	return &UserRepository{
		Repository: baseRepo,
	}, nil
}

// Query returns a type-safe query builder for User
//
// Example:
//
//	activeUsers, err := repo.Query().
//	    Where(Users.IsActive.Eq(true)).
//	    OrderBy(Users.ID.Desc()).
func (r *UserRepository) Query() *UserQuery {
	return &UserQuery{
		Query: r.Repository.Query(),
		repo:  r,
	}
}

// QueryContext returns a type-safe query builder for User with context support.
// Use this when you need to control query timeouts, cancellation, or pass context values.
//
// Examples:
//
//	// With timeout context
//	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
//	defer cancel()
//	results, err := repo.QueryContext(ctx).Find()
//
//	// With cancellation
//	ctx, cancel := context.WithCancel(context.Background())
//	go func() { time.Sleep(time.Second); cancel() }()
//	results, err := repo.QueryContext(ctx).Find()
//
//	// Complex query with context
//	results, err := repo.QueryContext(ctx).
//	    Where(Users.Email.Like("%search%")).
//	    Limit(100).Find()
func (r *UserRepository) QueryContext(ctx context.Context) *UserQuery {
	return &UserQuery{
		Query: r.Repository.QueryContext(ctx),
		repo:  r,
	}
}

// WithTodos includes the Todos relationship in queries
//
// Example:
//
//	userWithAllTodos, err := repo.WithTodos().Find()
//	// Each User will have its Todos slice populated
func (r *UserRepository) WithTodos() *UserQuery {
	return &UserQuery{
		Query: r.Repository.Query().Include("Todos"),
		repo:  r,
	}
}

// WithCategories includes the Categories relationship in queries
//
// Example:
//
//	userWithAllCategories, err := repo.WithCategories().Find()
//	// Each User will have its Categories slice populated
func (r *UserRepository) WithCategories() *UserQuery {
	return &UserQuery{
		Query: r.Repository.Query().Include("Categories"),
		repo:  r,
	}
}

// WithTags includes the Tags relationship in queries
//
// Example:
//
//	userWithTags, err := repo.WithTags().Find()
func (r *UserRepository) WithTags() *UserQuery {
	return &UserQuery{
		Query: r.Repository.Query().Include("Tags"),
		repo:  r,
	}
}

// UserQuery provides type-safe query building for User
//
// Query Methods (returned by Query()):
//   - Where(condition) - Add WHERE conditions
//   - OrderBy(expressions...) - Add ORDER BY
//   - Limit(limit) - Set LIMIT
//   - Offset(offset) - Set OFFSET
//   - Join(type, table, condition) - Generic join
//   - InnerJoin(table, condition) - Inner join
//   - LeftJoin(table, condition) - Left join
//   - RightJoin(table, condition) - Right join
//   - FullJoin(table, condition) - Full outer join
//   - Include(relationships...) - Load relationships
//   - IncludeWhere(relationship, conditions...) - Load relationships with conditions
//   - WithTx(tx) - Execute within transaction
//
// Execution Methods:
//   - Find() - Execute query and return all records
//   - First() - Execute query and return first record
//   - Count() - Execute count query
//   - Exists() - Check if any records exist
//   - Delete() - Execute DELETE query
//   - ExecuteRaw(query, args...) - Execute raw SQL
//
// Example usage:
//
//	// Simple query
//	results, err := repo.Query().Where(Users.FieldName.Eq("value")).Find()
//
//	// Complex query with joins and ordering
//	results, err := repo.Query().
//	    Where(condition).
//	    OrderBy("created_at DESC").
//	    Limit(10).
//	    Find()
//
//	// Query with relationships
//	results, err := repo.Query().
//	    Include("RelationshipName").
//	    Where(condition).
//	    Find()
type UserQuery struct {
	*orm.Query[User]
	repo *UserRepository
}

// Where applies a filtering condition to the query.
// Use the type-safe column references from Users for conditions.
//
// Examples:
//
//	// Exact match
//	query.Where(Users.Email.Eq("exact-value"))
//	// Pattern matching
//	query.Where(Users.Email.Like("%search%"))
//	// Multiple values
//	query.Where(Users.Email.In([]string{"value1", "value2"}))
//	// Boolean condition
//	query.Where(Users.IsActive.Eq(true))
//	// Time-based queries
//	query.Where(Users.CreatedAt.After(time.Now().AddDate(0, -1, 0)))
//	// Combine conditions
//	query.Where(Users.ID.Eq("value").And(Users.Email.IsNotNull()))
func (q *UserQuery) Where(condition orm.Condition) *UserQuery {
	q.Query = q.Query.Where(condition)
	return q
}

// OrderBy specifies the order of results using column names or expressions.
// Use DESC suffix for descending order, ASC (or no suffix) for ascending.
//
// Examples:
//
//	// Order by time field (most recent first)
//	query.OrderBy("id DESC")
//	// Order by string field alphabetically
//	query.OrderBy("id")
//	// Multiple columns
//	query.OrderBy("id DESC", "email")
//	// Complex expressions
//	query.OrderBy("CASE WHEN active THEN 0 ELSE 1 END", "created_at DESC")
func (q *UserQuery) OrderBy(expressions ...string) *UserQuery {
	q.Query = q.Query.OrderBy(expressions...)
	return q
}

// Limit restricts the number of results returned.
// Useful for pagination and preventing large result sets.
//
// Examples:
//
//	// Get first 10 results
//	query.Limit(10)
//	// Get top 100 most recent users
//	query.OrderBy("created_at DESC").Limit(100)
func (q *UserQuery) Limit(limit uint64) *UserQuery {
	q.Query = q.Query.Limit(limit)
	return q
}

// Offset skips the specified number of results.
// Typically used with Limit for pagination.
//
// Examples:
//
//	// Skip first 20 results (page 3 with 10 per page)
//	query.Offset(20).Limit(10)
//	// Get results 51-100
//	query.Offset(50).Limit(50)
func (q *UserQuery) Offset(offset uint64) *UserQuery {
	q.Query = q.Query.Offset(offset)
	return q
}

// Find executes the query and returns all matching User records.
// Returns an empty slice if no records are found.
//
// Examples:
//
//	// Get all users
//	allUsers, err := repo.Query().Find()
//	// Get all active users
//	activeUsers, err := repo.Query().Where(Users.IsActive.Eq(true)).Find()
//	// Search users by email
//	matchingUsers, err := repo.Query().Where(Users.Email.Like("%search%")).Find()
func (q *UserQuery) Find() ([]User, error) {
	return q.Query.Find()
}

// First executes the query and returns the first matching User record.
// Returns nil if no record is found. Use with OrderBy to get specific record.
//
// Examples:
//
//	// Get first user
//	firstUser, err := repo.Query().First()
//	// Get most recent user
//	latestUser, err := repo.Query().OrderBy("CreatedAt DESC").First()
//	// Get specific user by email
//	specificUser, err := repo.Query().Where(Users.Email.Eq("value")).First()
func (q *UserQuery) First() (*User, error) {
	return q.Query.First()
}

// Count returns the number of User records matching the query conditions.
// Does not load the actual records, making it efficient for large datasets.
//
// Examples:
//
//	// Count all users
//	total, err := repo.Query().Count()
//	// Count active users
//	activeCount, err := repo.Query().Where(Users.IsActive.Eq(true)).Count()
//	// Count users matching criteria
//	matchingCount, err := repo.Query().Where(Users.Email.Like("%search%")).Count()
func (q *UserQuery) Count() (int64, error) {
	return q.Query.Count()
}

// Exists checks if any User records match the query conditions.
// Returns true if at least one record exists, false otherwise.
// More efficient than Count() when you only need to know if records exist.
//
// Examples:
//
//	// Check if any users exist
//	hasAny, err := repo.Query().Exists()
//	// Check if user with specific email exists
//	exists, err := repo.Query().Where(Users.Email.Eq("value")).Exists()
//	// Check if any active users exist
//	hasActive, err := repo.Query().Where(Users.IsActive.Eq(true)).Exists()
func (q *UserQuery) Exists() (bool, error) {
	return q.Query.Exists()
}

// Delete removes all User records matching the query conditions.
// Returns the number of records deleted.
// WARNING: This is a bulk operation that cannot be undone.
//
// Examples:
//
//	// Delete all users (use with caution!)
//	deleted, err := repo.Query().Delete()
//	// Delete inactive users
//	deleted, err := repo.Query().Where(Users.IsActive.Eq(false)).Delete()
//	// Delete users matching criteria
//	deleted, err := repo.Query().Where(Users.Email.Like("temp_%")).Delete()
func (q *UserQuery) Delete() (int64, error) {
	return q.Query.Delete()
}
