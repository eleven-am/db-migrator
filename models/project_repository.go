//go:build !exclude_generated
// +build !exclude_generated

// Code generated by storm orm generate-orm; DO NOT EDIT.
//
// This file was automatically generated from Go struct definitions.
// Any changes made to this file will be lost when regenerating.
//
// Source package: models
// Model: Project
// Generated on: 2025-07-16 21:12:15 CEST
//
// To regenerate this file, run:
//   storm orm generate-orm --package=models
//
// For more information, see:
//   https://github.com/eleven-am/storm

package models

import (
	"context"
	"fmt"
	"github.com/eleven-am/storm/internal/orm"
	"github.com/jmoiron/sqlx"
)

// ProjectRepository provides type-safe operations for Project
// Inherits standard CRUD operations from orm.Repository:
// Find, FindAll, Create, Update, Delete, UpsertMany, BulkUpdate, etc.
type ProjectRepository struct {
	*orm.Repository[Project]
}

// newProjectRepository creates a new Project repository (internal use only - use Storm)
func newProjectRepository(db *sqlx.DB) (*ProjectRepository, error) {
	baseRepo, err := orm.NewRepository[Project](db, ProjectMetadata)
	if err != nil {
		return nil, fmt.Errorf("failed to create base repository: %w", err)
	}

	return &ProjectRepository{
		Repository: baseRepo,
	}, nil
}

// newProjectRepositoryWithTx creates a new Project repository using an existing transaction (internal use only - use Storm)
func newProjectRepositoryWithTx(tx *sqlx.Tx) (*ProjectRepository, error) {
	baseRepo, err := orm.NewRepositoryWithTx[Project](tx, ProjectMetadata)
	if err != nil {
		return nil, fmt.Errorf("failed to create base repository with transaction: %w", err)
	}

	return &ProjectRepository{
		Repository: baseRepo,
	}, nil
}

// Query returns a type-safe query builder for Project
//
// Example:
//
//	filteredProjects, err := repo.Query().
//	    Where(Projects.TeamId.Like("%search%")).
//	    OrderBy(Projects.Id.Desc()).
//	    Limit(10).
//	    Find()
func (r *ProjectRepository) Query() *ProjectQuery {
	return &ProjectQuery{
		Query: r.Repository.Query(),
		repo:  r,
	}
}

// QueryContext returns a type-safe query builder for Project with context
//
// Example:
//
//	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
//	defer cancel()
//	results, err := repo.QueryContext(ctx).
//	    Limit(100).
//	    Find()
func (r *ProjectRepository) QueryContext(ctx context.Context) *ProjectQuery {
	return &ProjectQuery{
		Query: r.Repository.QueryContext(ctx),
		repo:  r,
	}
}

// WithTeam includes the Team relationship in queries
//
// Example:
//
//	projectWithOwner, err := repo.WithTeam().Find()
//	// Each Project will have its Team loaded
func (r *ProjectRepository) WithTeam() *ProjectQuery {
	return &ProjectQuery{
		Query: r.Repository.Query().Include("Team"),
		repo:  r,
	}
}

// WithTriggers includes the Triggers relationship in queries
//
// Example:
//
//	projectWithAllTriggers, err := repo.WithTriggers().Find()
//	// Each Project will have its Triggers slice populated
func (r *ProjectRepository) WithTriggers() *ProjectQuery {
	return &ProjectQuery{
		Query: r.Repository.Query().Include("Triggers"),
		repo:  r,
	}
}

// WithAuthCredentials includes the AuthCredentials relationship in queries
//
// Example:
//
//	projectWithAllAuthCredentials, err := repo.WithAuthCredentials().Find()
//	// Each Project will have its AuthCredentials slice populated
func (r *ProjectRepository) WithAuthCredentials() *ProjectQuery {
	return &ProjectQuery{
		Query: r.Repository.Query().Include("AuthCredentials"),
		repo:  r,
	}
}

// WithBrokers includes the Brokers relationship in queries
//
// Example:
//
//	projectWithAllBrokers, err := repo.WithBrokers().Find()
//	// Each Project will have its Brokers slice populated
func (r *ProjectRepository) WithBrokers() *ProjectQuery {
	return &ProjectQuery{
		Query: r.Repository.Query().Include("Brokers"),
		repo:  r,
	}
}

// WithPipelines includes the Pipelines relationship in queries
//
// Example:
//
//	projectWithAllPipelines, err := repo.WithPipelines().Find()
//	// Each Project will have its Pipelines slice populated
func (r *ProjectRepository) WithPipelines() *ProjectQuery {
	return &ProjectQuery{
		Query: r.Repository.Query().Include("Pipelines"),
		repo:  r,
	}
}

// WithOauthTokens includes the OauthTokens relationship in queries
//
// Example:
//
//	projectWithAllOauthTokens, err := repo.WithOauthTokens().Find()
//	// Each Project will have its OauthTokens slice populated
func (r *ProjectRepository) WithOauthTokens() *ProjectQuery {
	return &ProjectQuery{
		Query: r.Repository.Query().Include("OauthTokens"),
		repo:  r,
	}
}

// WithPipelineEvents includes the PipelineEvents relationship in queries
//
// Example:
//
//	projectWithAllPipelineEvents, err := repo.WithPipelineEvents().Find()
//	// Each Project will have its PipelineEvents slice populated
func (r *ProjectRepository) WithPipelineEvents() *ProjectQuery {
	return &ProjectQuery{
		Query: r.Repository.Query().Include("PipelineEvents"),
		repo:  r,
	}
}

// WithExecutionLogs includes the ExecutionLogs relationship in queries
//
// Example:
//
//	projectWithAllExecutionLogs, err := repo.WithExecutionLogs().Find()
//	// Each Project will have its ExecutionLogs slice populated
func (r *ProjectRepository) WithExecutionLogs() *ProjectQuery {
	return &ProjectQuery{
		Query: r.Repository.Query().Include("ExecutionLogs"),
		repo:  r,
	}
}

// WithApiKeys includes the ApiKeys relationship in queries
//
// Example:
//
//	projectWithAllApiKeys, err := repo.WithApiKeys().Find()
//	// Each Project will have its ApiKeys slice populated
func (r *ProjectRepository) WithApiKeys() *ProjectQuery {
	return &ProjectQuery{
		Query: r.Repository.Query().Include("ApiKeys"),
		repo:  r,
	}
}

// ProjectQuery provides type-safe query building for Project
type ProjectQuery struct {
	*orm.Query[Project]
	repo *ProjectRepository
}

// Where adds a type-safe WHERE condition
func (q *ProjectQuery) Where(condition orm.Condition) *ProjectQuery {
	q.Query = q.Query.Where(condition)
	return q
}

// OrderBy adds ordering to the query
func (q *ProjectQuery) OrderBy(expressions ...string) *ProjectQuery {
	q.Query = q.Query.OrderBy(expressions...)
	return q
}

// Limit sets the LIMIT clause
func (q *ProjectQuery) Limit(limit uint64) *ProjectQuery {
	q.Query = q.Query.Limit(limit)
	return q
}

// Offset sets the OFFSET clause
func (q *ProjectQuery) Offset(offset uint64) *ProjectQuery {
	q.Query = q.Query.Offset(offset)
	return q
}

// Find executes the query and returns all matching records
func (q *ProjectQuery) Find() ([]Project, error) {
	return q.Query.Find()
}

// First executes the query and returns the first matching record
func (q *ProjectQuery) First() (*Project, error) {
	return q.Query.First()
}

// Count executes the query and returns the count of matching records
func (q *ProjectQuery) Count() (int64, error) {
	return q.Query.Count()
}

// Exists executes the query and returns true if any records match
func (q *ProjectQuery) Exists() (bool, error) {
	return q.Query.Exists()
}

// Delete executes the query and deletes all matching records
func (q *ProjectQuery) Delete() (int64, error) {
	return q.Query.Delete()
}
