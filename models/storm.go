//go:build !exclude_generated
// +build !exclude_generated

// Code generated by storm orm generate-orm; DO NOT EDIT.
//
// This file was automatically generated from Go struct definitions.
// Any changes made to this file will be lost when regenerating.
//
// Source package: models
// Models found: 15
// Generated on: 2025-07-16 21:12:15 CEST
//
// To regenerate this file, run:
//   storm orm generate-orm --package=models
//
// For more information, see:
//   https://github.com/eleven-am/storm

package models

import (
	"context"
	"fmt"
	"github.com/eleven-am/storm/internal/orm"
	"github.com/jmoiron/sqlx"
)

// Storm provides a centralized access point for all repositories
//
// Basic usage:
//
//	storm := NewStorm(db)
//	user, err := storm.Users.FindByID(ctx, "123")
//	users, err := storm.Users.Query().Where(Users.IsActive.Eq(true)).Find()
//
// All repositories inherit these methods from the base repository:
//   - Find(ctx, id) - Find a single record by primary key
//   - FindAll(ctx) - Find all records
//   - Create(ctx, model) - Create a new record
//   - Update(ctx, model) - Update an existing record
//   - Delete(ctx, id) - Delete a record by primary key
//   - UpsertMany(ctx, records, options) - Bulk upsert with conflict resolution
//   - BulkUpdate(ctx, records, options) - Update multiple records efficiently
//
// Transaction support:
//
//	err := storm.WithTransaction(ctx, func(txStorm *Storm) error {
//	    // All operations here run in a transaction
//	    return txStorm.Users.Create(ctx, newUser)
//	})
type Storm struct {
	*orm.Storm

	// All repositories

	ApiKeys *ApiKeyRepository

	AuditLogs *AuditLogRepository

	AuthCredentials *AuthCredentialRepository

	Brokers *BrokerRepository

	DlqMessages *DlqMessageRepository

	ExecutionLogs *ExecutionLogRepository

	OauthTokens *OauthTokenRepository

	Pipelines *PipelineRepository

	PipelineEvents *PipelineEventRepository

	Projects *ProjectRepository

	Stages *StageRepository

	Subscriptions *SubscriptionRepository

	Teams *TeamRepository

	Triggers *TriggerRepository

	Users *UserRepository
}

// NewStorm creates a new Storm instance with all repositories initialized
func NewStorm(db *sqlx.DB) *Storm {
	// Create base Storm
	baseStorm := orm.NewStorm(db)

	// Create our Storm with embedded base
	storm := &Storm{
		Storm: baseStorm,
	}

	// Initialize repositories
	storm.initializeRepositories()

	return storm
}

// WithTransaction executes a function within a database transaction
// It returns a transaction-aware Storm instance to the callback
func (s *Storm) WithTransaction(ctx context.Context, fn func(*Storm) error) error {
	return s.Storm.WithTransaction(ctx, func(baseStorm *orm.Storm) error {
		// Create transaction Storm with same embedded base
		txStorm := &Storm{
			Storm: baseStorm,
		}
		// Initialize repositories with transaction executor
		txStorm.initializeRepositories()
		return fn(txStorm)
	})
}

// WithTransactionOptions executes a function within a database transaction with options
func (s *Storm) WithTransactionOptions(ctx context.Context, opts *orm.TransactionOptions, fn func(*Storm) error) error {
	return s.Storm.WithTransactionOptions(ctx, opts, func(baseStorm *orm.Storm) error {
		// Create transaction Storm with same embedded base
		txStorm := &Storm{
			Storm: baseStorm,
		}
		// Initialize repositories with transaction executor
		txStorm.initializeRepositories()
		return fn(txStorm)
	})
}

// initializeRepositories initializes all repository instances
func (s *Storm) initializeRepositories() {
	executor := s.GetExecutor()

	// Initialize ApiKey repository
	if baseRepo, err := orm.NewRepositoryWithExecutor[ApiKey](executor, ApiKeyMetadata); err == nil {
		s.ApiKeys = &ApiKeyRepository{
			Repository: baseRepo,
		}
	} else {
		panic(fmt.Errorf("failed to initialize ApiKey repository: %w", err))
	}

	// Initialize AuditLog repository
	if baseRepo, err := orm.NewRepositoryWithExecutor[AuditLog](executor, AuditLogMetadata); err == nil {
		s.AuditLogs = &AuditLogRepository{
			Repository: baseRepo,
		}
	} else {
		panic(fmt.Errorf("failed to initialize AuditLog repository: %w", err))
	}

	// Initialize AuthCredential repository
	if baseRepo, err := orm.NewRepositoryWithExecutor[AuthCredential](executor, AuthCredentialMetadata); err == nil {
		s.AuthCredentials = &AuthCredentialRepository{
			Repository: baseRepo,
		}
	} else {
		panic(fmt.Errorf("failed to initialize AuthCredential repository: %w", err))
	}

	// Initialize Broker repository
	if baseRepo, err := orm.NewRepositoryWithExecutor[Broker](executor, BrokerMetadata); err == nil {
		s.Brokers = &BrokerRepository{
			Repository: baseRepo,
		}
	} else {
		panic(fmt.Errorf("failed to initialize Broker repository: %w", err))
	}

	// Initialize DlqMessage repository
	if baseRepo, err := orm.NewRepositoryWithExecutor[DlqMessage](executor, DlqMessageMetadata); err == nil {
		s.DlqMessages = &DlqMessageRepository{
			Repository: baseRepo,
		}
	} else {
		panic(fmt.Errorf("failed to initialize DlqMessage repository: %w", err))
	}

	// Initialize ExecutionLog repository
	if baseRepo, err := orm.NewRepositoryWithExecutor[ExecutionLog](executor, ExecutionLogMetadata); err == nil {
		s.ExecutionLogs = &ExecutionLogRepository{
			Repository: baseRepo,
		}
	} else {
		panic(fmt.Errorf("failed to initialize ExecutionLog repository: %w", err))
	}

	// Initialize OauthToken repository
	if baseRepo, err := orm.NewRepositoryWithExecutor[OauthToken](executor, OauthTokenMetadata); err == nil {
		s.OauthTokens = &OauthTokenRepository{
			Repository: baseRepo,
		}
	} else {
		panic(fmt.Errorf("failed to initialize OauthToken repository: %w", err))
	}

	// Initialize Pipeline repository
	if baseRepo, err := orm.NewRepositoryWithExecutor[Pipeline](executor, PipelineMetadata); err == nil {
		s.Pipelines = &PipelineRepository{
			Repository: baseRepo,
		}
	} else {
		panic(fmt.Errorf("failed to initialize Pipeline repository: %w", err))
	}

	// Initialize PipelineEvent repository
	if baseRepo, err := orm.NewRepositoryWithExecutor[PipelineEvent](executor, PipelineEventMetadata); err == nil {
		s.PipelineEvents = &PipelineEventRepository{
			Repository: baseRepo,
		}
	} else {
		panic(fmt.Errorf("failed to initialize PipelineEvent repository: %w", err))
	}

	// Initialize Project repository
	if baseRepo, err := orm.NewRepositoryWithExecutor[Project](executor, ProjectMetadata); err == nil {
		s.Projects = &ProjectRepository{
			Repository: baseRepo,
		}
	} else {
		panic(fmt.Errorf("failed to initialize Project repository: %w", err))
	}

	// Initialize Stage repository
	if baseRepo, err := orm.NewRepositoryWithExecutor[Stage](executor, StageMetadata); err == nil {
		s.Stages = &StageRepository{
			Repository: baseRepo,
		}
	} else {
		panic(fmt.Errorf("failed to initialize Stage repository: %w", err))
	}

	// Initialize Subscription repository
	if baseRepo, err := orm.NewRepositoryWithExecutor[Subscription](executor, SubscriptionMetadata); err == nil {
		s.Subscriptions = &SubscriptionRepository{
			Repository: baseRepo,
		}
	} else {
		panic(fmt.Errorf("failed to initialize Subscription repository: %w", err))
	}

	// Initialize Team repository
	if baseRepo, err := orm.NewRepositoryWithExecutor[Team](executor, TeamMetadata); err == nil {
		s.Teams = &TeamRepository{
			Repository: baseRepo,
		}
	} else {
		panic(fmt.Errorf("failed to initialize Team repository: %w", err))
	}

	// Initialize Trigger repository
	if baseRepo, err := orm.NewRepositoryWithExecutor[Trigger](executor, TriggerMetadata); err == nil {
		s.Triggers = &TriggerRepository{
			Repository: baseRepo,
		}
	} else {
		panic(fmt.Errorf("failed to initialize Trigger repository: %w", err))
	}

	// Initialize User repository
	if baseRepo, err := orm.NewRepositoryWithExecutor[User](executor, UserMetadata); err == nil {
		s.Users = &UserRepository{
			Repository: baseRepo,
		}
	} else {
		panic(fmt.Errorf("failed to initialize User repository: %w", err))
	}

}
