package orm

import (
	"context"
	"fmt"
	"reflect"
	"strings"
	"time"

	"github.com/Masterminds/squirrel"
	"github.com/jmoiron/sqlx"
)

// Create inserts a new record into the database
func (r *Repository[T]) Create(ctx context.Context, record *T) error {
	if record == nil {
		return &Error{
			Op:    "create",
			Table: r.tableName,
			Err:   fmt.Errorf("record cannot be nil"),
		}
	}

	if err := r.executeBeforeHook(HookBeforeCreate, ctx, record, "", nil); err != nil {
		return &Error{
			Op:    "create",
			Table: r.tableName,
			Err:   fmt.Errorf("before create hook failed: %w", err),
		}
	}

	start := time.Now()

	query := squirrel.Insert(r.tableName).
		PlaceholderFormat(squirrel.Dollar)

	recordValue := reflect.ValueOf(record).Elem()
	recordType := recordValue.Type()

	columns := make([]string, 0, len(r.insertColumns))
	values := make([]interface{}, 0, len(r.insertColumns))

	for _, column := range r.insertColumns {
		fieldName := r.reverseMap[column]
		_, found := recordType.FieldByName(fieldName)
		if !found {
			continue
		}

		fieldValue := recordValue.FieldByName(fieldName)
		if !fieldValue.IsValid() {
			continue
		}

		columns = append(columns, column)
		values = append(values, fieldValue.Interface())
	}

	query = query.Columns(columns...).Values(values...)

	returningCols := make([]string, 0)
	for _, field := range r.tableDef.Fields {
		if r.isAutoGenerated(field) {
			returningCols = append(returningCols, field.DBName)
		}
	}

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return &Error{
			Op:    "create",
			Table: r.tableName,
			Err:   fmt.Errorf("failed to build query: %w", err),
		}
	}

	if len(returningCols) > 0 {
		sqlQuery += " RETURNING " + strings.Join(returningCols, ", ")
	}

	var execErr error
	if len(returningCols) > 0 {

		row := r.db.QueryRowContext(ctx, sqlQuery, args...)

		scanArgs := make([]interface{}, len(returningCols))
		for i, col := range returningCols {
			fieldName := r.reverseMap[col]
			fieldValue := recordValue.FieldByName(fieldName)
			if fieldValue.CanAddr() {
				scanArgs[i] = fieldValue.Addr().Interface()
			}
		}

		if err := row.Scan(scanArgs...); err != nil {
			execErr = err
		}
	} else {

		if _, err := r.db.ExecContext(ctx, sqlQuery, args...); err != nil {
			execErr = err
		}
	}

	duration := time.Since(start)

	if hookErr := r.executeAfterHook(HookAfterCreate, ctx, record, sqlQuery, args, execErr, duration); hookErr != nil {

		if execErr == nil {

		}
	}

	if execErr != nil {
		return ParsePostgreSQLError(execErr, "create", r.tableName)
	}

	return nil
}

// FindByID finds a record by its primary key
func (r *Repository[T]) FindByID(ctx context.Context, id interface{}) (*T, error) {
	if len(r.primaryKeys) != 1 {
		return nil, &Error{
			Op:    "findByID",
			Table: r.tableName,
			Err:   fmt.Errorf("composite primary keys not supported"),
		}
	}

	query := squirrel.Select(r.selectColumns...).
		From(r.tableName).
		Where(squirrel.Eq{r.primaryKeys[0]: id}).
		PlaceholderFormat(squirrel.Dollar).
		Limit(1)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, &Error{
			Op:    "findByID",
			Table: r.tableName,
			Err:   fmt.Errorf("failed to build query: %w", err),
		}
	}

	var record T
	err = r.db.GetContext(ctx, &record, sqlQuery, args...)
	if err != nil {
		return nil, ParsePostgreSQLError(err, "findByID", r.tableName)
	}

	return &record, nil
}

// Update modifies an existing record
func (r *Repository[T]) Update(ctx context.Context, record *T) error {
	if record == nil {
		return &Error{
			Op:    "update",
			Table: r.tableName,
			Err:   fmt.Errorf("record cannot be nil"),
		}
	}

	if err := r.executeBeforeHook(HookBeforeUpdate, ctx, record, "", nil); err != nil {
		return &Error{
			Op:    "update",
			Table: r.tableName,
			Err:   fmt.Errorf("before update hook failed: %w", err),
		}
	}

	start := time.Now()

	query := squirrel.Update(r.tableName).
		PlaceholderFormat(squirrel.Dollar)

	recordValue := reflect.ValueOf(record).Elem()
	recordType := recordValue.Type()

	for _, column := range r.updateColumns {
		fieldName := r.reverseMap[column]
		_, found := recordType.FieldByName(fieldName)
		if !found {
			continue
		}

		fieldValue := recordValue.FieldByName(fieldName)
		if !fieldValue.IsValid() {
			continue
		}

		query = query.Set(column, fieldValue.Interface())
	}

	for _, pkCol := range r.primaryKeys {
		fieldName := r.reverseMap[pkCol]
		fieldValue := recordValue.FieldByName(fieldName)
		if !fieldValue.IsValid() {
			return &Error{
				Op:    "update",
				Table: r.tableName,
				Err:   fmt.Errorf("primary key field %s is invalid", fieldName),
			}
		}
		query = query.Where(squirrel.Eq{pkCol: fieldValue.Interface()})
	}

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return &Error{
			Op:    "update",
			Table: r.tableName,
			Err:   fmt.Errorf("failed to build query: %w", err),
		}
	}

	var execErr error
	var rowsAffected int64

	result, err := r.db.ExecContext(ctx, sqlQuery, args...)
	if err != nil {
		execErr = fmt.Errorf("failed to execute update: %w", err)
	} else {
		rowsAffected, err = result.RowsAffected()
		if err != nil {
			execErr = fmt.Errorf("failed to get rows affected: %w", err)
		} else if rowsAffected == 0 {
			execErr = ErrNotFound
		}
	}

	duration := time.Since(start)

	if hookErr := r.executeAfterHook(HookAfterUpdate, ctx, record, sqlQuery, args, execErr, duration); hookErr != nil {

		if execErr == nil {

		}
	}

	if execErr != nil {
		return &Error{
			Op:    "update",
			Table: r.tableName,
			Err:   execErr,
		}
	}

	return nil
}

// Delete removes a record by ID
func (r *Repository[T]) Delete(ctx context.Context, id interface{}) error {
	if len(r.primaryKeys) != 1 {
		return &Error{
			Op:    "delete",
			Table: r.tableName,
			Err:   fmt.Errorf("composite primary keys not supported"),
		}
	}

	if err := r.executeBeforeHook(HookBeforeDelete, ctx, id, "", nil); err != nil {
		return &Error{
			Op:    "delete",
			Table: r.tableName,
			Err:   fmt.Errorf("before delete hook failed: %w", err),
		}
	}

	start := time.Now()

	query := squirrel.Delete(r.tableName).
		Where(squirrel.Eq{r.primaryKeys[0]: id}).
		PlaceholderFormat(squirrel.Dollar)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return &Error{
			Op:    "delete",
			Table: r.tableName,
			Err:   fmt.Errorf("failed to build query: %w", err),
		}
	}

	var execErr error
	var rowsAffected int64

	result, err := r.db.ExecContext(ctx, sqlQuery, args...)
	if err != nil {
		execErr = fmt.Errorf("failed to execute delete: %w", err)
	} else {
		rowsAffected, err = result.RowsAffected()
		if err != nil {
			execErr = fmt.Errorf("failed to get rows affected: %w", err)
		} else if rowsAffected == 0 {
			execErr = ErrNotFound
		}
	}

	duration := time.Since(start)

	if hookErr := r.executeAfterHook(HookAfterDelete, ctx, id, sqlQuery, args, execErr, duration); hookErr != nil {

		if execErr == nil {

		}
	}

	if execErr != nil {
		return &Error{
			Op:    "delete",
			Table: r.tableName,
			Err:   execErr,
		}
	}

	return nil
}

// DeleteRecord removes the given record
func (r *Repository[T]) DeleteRecord(ctx context.Context, record *T) error {
	if record == nil {
		return &Error{
			Op:    "deleteRecord",
			Table: r.tableName,
			Err:   fmt.Errorf("record cannot be nil"),
		}
	}

	recordValue := reflect.ValueOf(record).Elem()

	query := squirrel.Delete(r.tableName).
		PlaceholderFormat(squirrel.Dollar)

	for _, pkCol := range r.primaryKeys {
		fieldName := r.reverseMap[pkCol]
		fieldValue := recordValue.FieldByName(fieldName)
		if !fieldValue.IsValid() {
			return &Error{
				Op:    "deleteRecord",
				Table: r.tableName,
				Err:   fmt.Errorf("primary key field %s is invalid", fieldName),
			}
		}
		query = query.Where(squirrel.Eq{pkCol: fieldValue.Interface()})
	}

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return &Error{
			Op:    "deleteRecord",
			Table: r.tableName,
			Err:   fmt.Errorf("failed to build query: %w", err),
		}
	}

	result, err := r.db.ExecContext(ctx, sqlQuery, args...)
	if err != nil {
		return &Error{
			Op:    "deleteRecord",
			Table: r.tableName,
			Err:   fmt.Errorf("failed to execute delete: %w", err),
		}
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return &Error{
			Op:    "deleteRecord",
			Table: r.tableName,
			Err:   fmt.Errorf("failed to get rows affected: %w", err),
		}
	}

	if rowsAffected == 0 {
		return &Error{
			Op:    "deleteRecord",
			Table: r.tableName,
			Err:   ErrNotFound,
		}
	}

	return nil
}

// CreateMany inserts multiple records in a single transaction
func (r *Repository[T]) CreateMany(ctx context.Context, records []*T) error {
	if len(records) == 0 {
		return nil
	}

	var executor DBExecutor
	needsCommit := false

	if _, isTransaction := r.db.(*sqlx.Tx); isTransaction {

		executor = r.db
	} else {

		db := r.db.(*sqlx.DB)
		tx, err := db.BeginTxx(ctx, nil)
		if err != nil {
			return &Error{
				Op:    "createMany",
				Table: r.tableName,
				Err:   fmt.Errorf("failed to begin transaction: %w", err),
			}
		}
		defer tx.Rollback()
		executor = tx
		needsCommit = true
	}

	query := squirrel.Insert(r.tableName).
		PlaceholderFormat(squirrel.Dollar).
		Columns(r.insertColumns...)

	for _, record := range records {
		if record == nil {
			continue
		}

		recordValue := reflect.ValueOf(record).Elem()
		recordType := recordValue.Type()

		values := make([]interface{}, 0, len(r.insertColumns))
		for _, column := range r.insertColumns {
			fieldName := r.reverseMap[column]
			_, found := recordType.FieldByName(fieldName)
			if !found {
				values = append(values, nil)
				continue
			}

			fieldValue := recordValue.FieldByName(fieldName)
			if !fieldValue.IsValid() {
				values = append(values, nil)
				continue
			}

			values = append(values, fieldValue.Interface())
		}

		query = query.Values(values...)
	}

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return &Error{
			Op:    "createMany",
			Table: r.tableName,
			Err:   fmt.Errorf("failed to build batch insert query: %w", err),
		}
	}

	_, err = executor.ExecContext(ctx, sqlQuery, args...)
	if err != nil {
		return &Error{
			Op:    "createMany",
			Table: r.tableName,
			Err:   fmt.Errorf("failed to execute batch insert: %w", err),
		}
	}

	if needsCommit {
		tx := executor.(*sqlx.Tx)
		if err := tx.Commit(); err != nil {
			return &Error{
				Op:    "createMany",
				Table: r.tableName,
				Err:   fmt.Errorf("failed to commit transaction: %w", err),
			}
		}
	}

	return nil
}

// UpdateMany updates multiple records based on a condition
func (r *Repository[T]) UpdateMany(ctx context.Context, updates map[string]interface{}, condition Condition) (int64, error) {
	if len(updates) == 0 {
		return 0, &Error{
			Op:    "updateMany",
			Table: r.tableName,
			Err:   fmt.Errorf("no updates provided"),
		}
	}

	query := squirrel.Update(r.tableName).
		PlaceholderFormat(squirrel.Dollar).
		Where(condition.ToSqlizer())

	for column, value := range updates {
		query = query.Set(column, value)
	}

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return 0, &Error{
			Op:    "updateMany",
			Table: r.tableName,
			Err:   fmt.Errorf("failed to build update query: %w", err),
		}
	}

	result, err := r.db.ExecContext(ctx, sqlQuery, args...)
	if err != nil {
		return 0, &Error{
			Op:    "updateMany",
			Table: r.tableName,
			Err:   fmt.Errorf("failed to execute update: %w", err),
		}
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return 0, &Error{
			Op:    "updateMany",
			Table: r.tableName,
			Err:   fmt.Errorf("failed to get rows affected: %w", err),
		}
	}

	return rowsAffected, nil
}
