package orm

import (
	"fmt"
	"reflect"
	"strings"

	"github.com/eleven-am/storm/internal/parser"
	"github.com/jmoiron/sqlx"
)

// Repository provides type-safe database operations for a specific model type
type Repository[T any] struct {
	db       DBExecutor // Keep this accessible for internal packages
	parser   *parser.StructParser
	tableDef parser.TableDefinition

	// Cached information for performance
	tableName     string
	columnMap     map[string]string // Go field -> DB column
	reverseMap    map[string]string // DB column -> Go field
	primaryKeys   []string
	insertColumns []string
	updateColumns []string
	selectColumns []string

	// Relationship management
	relationshipManager *relationshipManager

	// Hook management
	hookManager *hookManager

	// Prepared statements cache
	insertStmt *sqlx.NamedStmt
	updateStmt *sqlx.NamedStmt
}

// NewRepository creates a new repository for the specified type
func NewRepository[T any](db *sqlx.DB) (*Repository[T], error) {
	return NewRepositoryWithExecutor[T](db)
}

// NewRepositoryWithTx creates a new repository using an existing transaction
func NewRepositoryWithTx[T any](tx *sqlx.Tx) (*Repository[T], error) {
	return NewRepositoryWithExecutor[T](tx)
}

// NewRepositoryWithExecutor creates a new repository with a custom executor
func NewRepositoryWithExecutor[T any](executor DBExecutor) (*Repository[T], error) {
	repo := &Repository[T]{
		db:         executor,
		parser:     parser.NewStructParser(),
		columnMap:  make(map[string]string),
		reverseMap: make(map[string]string),
	}

	if err := repo.initialize(); err != nil {
		return nil, &Error{
			Op:    "initialize",
			Table: repo.tableName,
			Err:   err,
		}
	}

	return repo, nil
}

// initialize parses the struct and prepares metadata
func (r *Repository[T]) initialize() error {
	var zero T
	structType := reflect.TypeOf(zero)

	// Remove pointer if necessary
	if structType.Kind() == reflect.Ptr {
		structType = structType.Elem()
	}

	if structType.Kind() != reflect.Struct {
		return ErrInvalidStruct
	}

	// Parse the struct using existing parser
	structName := structType.Name()
	tableDef, err := r.parseStructType(structType, structName)
	if err != nil {
		return fmt.Errorf("failed to parse struct: %w", err)
	}

	r.tableDef = tableDef
	r.tableName = tableDef.TableName

	// Build column mappings
	for _, field := range tableDef.Fields {
		r.columnMap[field.Name] = field.DBName
		r.reverseMap[field.DBName] = field.Name
		r.selectColumns = append(r.selectColumns, field.DBName)

		// Identify primary keys
		if r.isPrimaryKey(field) {
			r.primaryKeys = append(r.primaryKeys, field.DBName)
		}

		// Build insert/update column lists
		if !r.isAutoGenerated(field) {
			r.insertColumns = append(r.insertColumns, field.DBName)
		}
		if !r.isPrimaryKey(field) && !r.isAutoGenerated(field) {
			r.updateColumns = append(r.updateColumns, field.DBName)
		}
	}

	if len(r.primaryKeys) == 0 {
		return ErrNoPrimaryKey
	}

	// Initialize relationship manager and parse relationships
	r.relationshipManager = newRelationshipManager(r.tableName)
	if err := r.relationshipManager.parseRelationships(structType); err != nil {
		return fmt.Errorf("failed to parse relationships: %w", err)
	}

	// Initialize hook manager
	r.hookManager = newHookManager()

	return nil
}

// parseStructType converts a reflect.Type to TableDefinition
func (r *Repository[T]) parseStructType(structType reflect.Type, structName string) (parser.TableDefinition, error) {
	tableDef := parser.TableDefinition{
		StructName: structName,
		TableName:  r.deriveTableName(structName),
		Fields:     make([]parser.FieldDefinition, 0),
		TableLevel: make(map[string]string),
	}

	for i := 0; i < structType.NumField(); i++ {
		field := structType.Field(i)

		// Skip unexported fields
		if !field.IsExported() {
			continue
		}

		// Parse field tags
		dbTag := field.Tag.Get("db")
		dbdefTag := field.Tag.Get("dbdef")

		// Skip non-database fields
		if dbTag == "-" {
			continue
		}

		fieldDef := parser.FieldDefinition{
			Name:     field.Name,
			Type:     field.Type.String(),
			DBTag:    dbTag,
			DBDefTag: dbdefTag,
		}

		// Set database column name
		if dbTag != "" {
			fieldDef.DBName = dbTag
		} else {
			fieldDef.DBName = r.toSnakeCase(field.Name)
		}

		// Parse dbdef tag
		if dbdefTag != "" {
			tagParser := parser.NewTagParser()
			fieldDef.DBDef = tagParser.ParseDBDefTag(dbdefTag)
		} else {
			fieldDef.DBDef = make(map[string]string)
		}

		// Determine if pointer/array
		fieldDef.IsPointer = field.Type.Kind() == reflect.Ptr
		fieldDef.IsArray = field.Type.Kind() == reflect.Slice || field.Type.Kind() == reflect.Array

		tableDef.Fields = append(tableDef.Fields, fieldDef)
	}

	return tableDef, nil
}

// Helper methods
func (r *Repository[T]) isPrimaryKey(field parser.FieldDefinition) bool {
	_, exists := field.DBDef["primary_key"]
	return exists
}

func (r *Repository[T]) isAutoGenerated(field parser.FieldDefinition) bool {
	// Check for auto_increment or default values that are auto-generated
	if _, exists := field.DBDef["auto_increment"]; exists {
		return true
	}

	defaultVal, hasDefault := field.DBDef["default"]
	if hasDefault {
		// PostgreSQL auto-generation patterns
		autoGenDefaults := []string{
			"gen_random_uuid()",
			"uuid_generate_v4()",
			"now()",
			"current_timestamp",
		}
		for _, pattern := range autoGenDefaults {
			if strings.Contains(strings.ToLower(defaultVal), pattern) {
				return true
			}
		}
	}

	return false
}

func (r *Repository[T]) deriveTableName(structName string) string {
	// Simple pluralization - convert PascalCase to snake_case and add 's'
	snake := r.toSnakeCase(structName)

	// Basic pluralization rules for PostgreSQL
	if strings.HasSuffix(snake, "y") && !strings.HasSuffix(snake, "ey") {
		return snake[:len(snake)-1] + "ies"
	}
	if strings.HasSuffix(snake, "s") || strings.HasSuffix(snake, "sh") ||
		strings.HasSuffix(snake, "ch") || strings.HasSuffix(snake, "x") {
		return snake + "es"
	}
	return snake + "s"
}

func (r *Repository[T]) toSnakeCase(s string) string {
	var result strings.Builder

	for i, r := range s {
		if i > 0 && (r >= 'A' && r <= 'Z') {
			result.WriteRune('_')
		}
		if r >= 'A' && r <= 'Z' {
			result.WriteRune(r - 'A' + 'a')
		} else {
			result.WriteRune(r)
		}
	}

	return result.String()
}

// Getter methods
func (r *Repository[T]) TableName() string {
	return r.tableName
}

func (r *Repository[T]) PrimaryKeys() []string {
	return r.primaryKeys
}

func (r *Repository[T]) Columns() []string {
	return r.selectColumns
}

// relationships returns the relationship manager (internal use)
func (r *Repository[T]) relationships() *relationshipManager {
	return r.relationshipManager
}

// WithRelationships creates a query that can eager load relationships
func (r *Repository[T]) WithRelationships() *Query[T] {
	return r.Query()
}
