package orm_generator

// metadataTemplate generates compile-time metadata for models
const metadataTemplate = `//go:build !exclude_generated
// +build !exclude_generated

// Code generated by storm orm generate-orm; DO NOT EDIT.
//
// This file was automatically generated from Go struct definitions.
// Any changes made to this file will be lost when regenerating.
//
// Source package: {{ .Package }}
// Model: {{ .Model.Name }}
// Generated on: {{ .Now.Format "2006-01-02 15:04:05 MST" }}
//
// To regenerate this file, run:
//   storm orm generate-orm --package={{ .Package }}
//
// For more information, see:
//   https://github.com/eleven-am/storm

package {{ .Package }}

import (
	orm "github.com/eleven-am/storm/pkg/storm-orm"
)

// {{ .Model.Name }}Metadata provides compile-time metadata for {{ .Model.Name }}
var {{ .Model.Name }}Metadata = &storm.ModelMetadata{
	TableName:  "{{ .Model.TableName }}",
	StructName: "{{ .Model.Name }}",
	
	Columns: map[string]*storm.ColumnMetadata{
		{{- range .Model.Columns }}
		"{{ .Name }}": {
			FieldName:       "{{ .Name }}",
			DBName:          "{{ .DBName }}",
			GoType:          "{{ .Type }}",
			IsPointer:       {{ .IsPointer }},
			IsPrimaryKey:    {{ .IsPrimaryKey }},
			IsAutoGenerated: {{ .IsAutoGenerated }},
			
			// Generated accessor functions for zero-reflection field access
			GetValue: func(model interface{}) interface{} {
				m := model.({{ $.Model.Name }})
				{{- if .IsPointer }}
				if m.{{ .Name }} != nil {
					return *m.{{ .Name }}
				}
				return nil
				{{- else }}
				return m.{{ .Name }}
				{{- end }}
			},
			{{- if .IsPointer }}
			IsNil: func(model interface{}) bool {
				return model.({{ $.Model.Name }}).{{ .Name }} == nil
			},
			{{- end }}
		},
		{{- end }}
	},
	
	ColumnMap: map[string]string{
		{{- range .Model.Columns }}
		"{{ .Name }}": "{{ .DBName }}",
		{{- end }}
	},
	
	ReverseMap: map[string]string{
		{{- range .Model.Columns }}
		"{{ .DBName }}": "{{ .Name }}",
		{{- end }}
	},
	
	PrimaryKeys: []string{
		{{- range .Model.PrimaryKeys }}
		"{{ . }}",
		{{- end }}
	},
	
	Relationships: map[string]*orm.RelationshipMetadata{
		{{- range .Model.Relationships }}
		"{{ .Name }}": {
			Name:   "{{ .Name }}",
			Type:   "{{ .Relationship.Type }}",
			Target: "{{ .Relationship.Target }}",
			{{- if .Relationship.ForeignKey }}
			ForeignKey: "{{ .Relationship.ForeignKey }}",
			{{- end }}
			{{- if .Relationship.SourceKey }}
			SourceKey: "{{ .Relationship.SourceKey }}",
			{{- end }}
			{{- if .Relationship.TargetKey }}
			TargetKey: "{{ .Relationship.TargetKey }}",
			{{- end }}
			{{- if .Relationship.Through }}
			Through: "{{ .Relationship.Through }}",
			{{- end }}
			{{- if .Relationship.SourceFK }}
			ThroughFK: "{{ .Relationship.SourceFK }}",
			{{- end }}
			{{- if .Relationship.TargetFK }}
			ThroughTK: "{{ .Relationship.TargetFK }}",
			{{- end }}
			
			// Generated accessor functions for relationships
			SetValue: func(model interface{}, value interface{}) {
				{{- if .IsArray }}
				model.(*{{ $.Model.Name }}).{{ .Name }} = value.([]{{ .Relationship.Target }})
				{{- else }}
				model.(*{{ $.Model.Name }}).{{ .Name }} = value.(*{{ .Relationship.Target }})
				{{- end }}
			},
			IsSlice: {{ .IsArray }},
		},
		{{- end }}
	},
}
`

// columnTemplate generates type-safe column constants
const columnTemplate = `//go:build !exclude_generated
// +build !exclude_generated

// Code generated by storm orm generate-orm; DO NOT EDIT.
//
// This file was automatically generated from Go struct definitions.
// Any changes made to this file will be lost when regenerating.
//
// Source package: {{ .Package }}
// Models found: {{ len .Models }}
// Generated on: {{ .Now.Format "2006-01-02 15:04:05 MST" }}
//
// To regenerate this file, run:
//   storm orm generate-orm --package={{ .Package }}
//
// For more information, see:
//   https://github.com/eleven-am/storm

package {{ .Package }}

import (
	"time"
	orm "github.com/eleven-am/storm/pkg/storm-orm"
)

{{range $modelName, $model := .Models}}
// {{ $model.Name }}s provides type-safe column references for {{ $model.Name }}
var {{ $model.Name }}s = struct {
	{{range $model.Columns}}
	{{ sanitizeGoName .Name }} {{ if eq .Type "string" }}orm.StringColumn{{ else if eq .Type "int" }}orm.NumericColumn[int]{{ else if eq .Type "int32" }}orm.NumericColumn[int32]{{ else if eq .Type "int64" }}orm.NumericColumn[int64]{{ else if eq .Type "float32" }}orm.NumericColumn[float32]{{ else if eq .Type "float64" }}orm.NumericColumn[float64]{{ else if eq .Type "bool" }}orm.BoolColumn{{ else if eq .Type "time.Time" }}orm.TimeColumn{{ else if hasPrefix .Type "[]" }}orm.ArrayColumn[{{ .Type }}]{{ else if eq .Type "json.RawMessage" }}orm.JSONBColumn{{ else if eq .Type "orm.JSONData" }}orm.JSONBColumn{{ else if hasPrefix .Type "JSONField[" }}orm.JSONBColumn{{ else if eq .Type "" }}orm.StringColumn{{ else }}orm.Column[interface{}]{{ end }} ` + "`json:\"{{ .DBName }}\"`" + `
	{{end}}
}{
	{{range $model.Columns}}
	{{ sanitizeGoName .Name }}: {{ if eq .Type "string" }}orm.StringColumn{Column: orm.Column[string]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}{{ else if eq .Type "int" }}orm.NumericColumn[int]{ComparableColumn: orm.ComparableColumn[int]{Column: orm.Column[int]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}}{{ else if eq .Type "int32" }}orm.NumericColumn[int32]{ComparableColumn: orm.ComparableColumn[int32]{Column: orm.Column[int32]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}}{{ else if eq .Type "int64" }}orm.NumericColumn[int64]{ComparableColumn: orm.ComparableColumn[int64]{Column: orm.Column[int64]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}}{{ else if eq .Type "float32" }}orm.NumericColumn[float32]{ComparableColumn: orm.ComparableColumn[float32]{Column: orm.Column[float32]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}}{{ else if eq .Type "float64" }}orm.NumericColumn[float64]{ComparableColumn: orm.ComparableColumn[float64]{Column: orm.Column[float64]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}}{{ else if eq .Type "bool" }}orm.BoolColumn{Column: orm.Column[bool]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}{{ else if eq .Type "time.Time" }}orm.TimeColumn{ComparableColumn: orm.ComparableColumn[time.Time]{Column: orm.Column[time.Time]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}}{{ else if hasPrefix .Type "[]" }}orm.ArrayColumn[{{ .Type }}]{Column: orm.Column[{{ .Type }}]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}{{ else if eq .Type "json.RawMessage" }}orm.JSONBColumn{Column: orm.Column[interface{}]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}{{ else if eq .Type "orm.JSONData" }}orm.JSONBColumn{Column: orm.Column[interface{}]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}{{ else if hasPrefix .Type "JSONField[" }}orm.JSONBColumn{Column: orm.Column[interface{}]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}{{ else if eq .Type "" }}orm.StringColumn{Column: orm.Column[string]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}{{ else }}orm.Column[interface{}]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}{{ end }},
	{{end}}
}

// {{ $model.Name }}Table provides table-level operations for {{ $model.Name }}
var {{ $model.Name }}Table = orm.Table{
	Name: "{{ $model.TableName }}",
	PrimaryKeys: []string{ {{ range $model.PrimaryKeys }}"{{ . }}", {{ end }} },
}

{{end}}
`

// repositoryTemplate generates repository implementations
const repositoryTemplate = `//go:build !exclude_generated
// +build !exclude_generated

// Code generated by storm orm generate-orm; DO NOT EDIT.
//
// This file was automatically generated from Go struct definitions.
// Any changes made to this file will be lost when regenerating.
//
// Source package: {{ .Package }}
// Model: {{ .Model.Name }}
// Generated on: {{ .Now.Format "2006-01-02 15:04:05 MST" }}
//
// To regenerate this file, run:
//   storm orm generate-orm --package={{ .Package }}
//
// For more information, see:
//   https://github.com/eleven-am/storm

package {{ .Package }}

import (
	"context"
	"fmt"
	orm "github.com/eleven-am/storm/pkg/storm-orm"
	"github.com/jmoiron/sqlx"
)

// {{ .Model.Name }}Repository provides type-safe operations for {{ .Model.Name }}
//
// The repository inherits these operations from storm.Repository:
//
// Single Record Operations:
//   - Create(ctx, record) - Insert single record
//   - FindByID(ctx, id) - Find record by primary key
//   - Update(ctx, record) - Update single record by primary key
//   - Delete(ctx, id) - Delete record by primary key ID
//   - DeleteRecord(ctx, record) - Delete record using the record instance
//
// Batch Operations:
//   - CreateMany(ctx, records) - Insert multiple records in transaction
//   - UpdateMany(ctx, updates, condition) - Update multiple records with condition
//   - BulkUpdate(ctx, records, opts) - Bulk update using CTE with VALUES
//   - Upsert(ctx, record, opts) - Insert or update on conflict
//   - UpsertMany(ctx, records, opts) - Batch upsert operations
//
// Query Building:
//   - Query() - Create new query builder for complex queries
//   - QueryContext(ctx) - Create query builder with context support
//
// Example usage:
//   // Single operations
//   {{ lower .Model.Name }}, err := repo.FindByID(ctx, "123")
//   err = repo.Create(ctx, &new{{ .Model.Name }})
//   
//   // Batch operations
//   err = repo.CreateMany(ctx, multiple{{ .Model.Name }}s)
//   rowsAffected, err := repo.UpdateMany(ctx, updates, condition)
//   
//   // Complex queries
//   results, err := repo.Query().Where(condition).OrderBy("created_at DESC").Find()
type {{ .Model.Name }}Repository struct {
	*orm.Repository[{{ .Model.Name }}]
}

func new{{ .Model.Name }}Repository(db *sqlx.DB) (*{{ .Model.Name }}Repository, error) {
	baseRepo, err := orm.NewRepository[{{ .Model.Name }}](db, {{ .Model.Name }}Metadata)
	if err != nil {
		return nil, fmt.Errorf("failed to create base repository: %w", err)
	}

	return &{{ .Model.Name }}Repository{
		Repository: baseRepo,
	}, nil
}

func new{{ .Model.Name }}RepositoryWithTx(tx *sqlx.Tx) (*{{ .Model.Name }}Repository, error) {
	baseRepo, err := orm.NewRepositoryWithTx[{{ .Model.Name }}](tx, {{ .Model.Name }}Metadata)
	if err != nil {
		return nil, fmt.Errorf("failed to create base repository with transaction: %w", err)
	}

	return &{{ .Model.Name }}Repository{
		Repository: baseRepo,
	}, nil
}

// Query returns a type-safe query builder for {{ .Model.Name }}
//
// Example:
{{- $firstStringField := "" }}
{{- $firstBoolField := "" }}
{{- $firstTimeField := "" }}
{{- $primaryKeyField := "" }}
{{- range .Model.Columns }}
{{- if and (eq .Type "string") (eq $firstStringField "") (not .IsPrimaryKey) }}{{ $firstStringField = .Name }}{{ end }}
{{- if and (eq .Type "bool") (eq $firstBoolField "") }}{{ $firstBoolField = .Name }}{{ end }}
{{- if and (eq .Type "time.Time") (eq $firstTimeField "") (not (contains .Name "At")) }}{{ $firstTimeField = .Name }}{{ end }}
{{- if and .IsPrimaryKey (eq $primaryKeyField "") }}{{ $primaryKeyField = .Name }}{{ end }}
{{- end }}
{{- if $firstBoolField }}
//   active{{ .Model.Name }}s, err := repo.Query().
//       Where({{ .Model.Name }}s.{{ sanitizeGoName $firstBoolField }}.Eq(true)).
{{- else if $firstStringField }}
//   filtered{{ .Model.Name }}s, err := repo.Query().
//       Where({{ .Model.Name }}s.{{ sanitizeGoName $firstStringField }}.Like("%search%")).
{{- else }}
//   all{{ .Model.Name }}s, err := repo.Query().
{{- end }}
{{- if $firstTimeField }}
//       OrderBy({{ .Model.Name }}s.{{ sanitizeGoName $firstTimeField }}.Desc()).
{{- else if $primaryKeyField }}
//       OrderBy({{ .Model.Name }}s.{{ sanitizeGoName $primaryKeyField }}.Desc()).
{{- else }}
//       OrderBy("id DESC").
{{- end }}
func (r *{{ .Model.Name }}Repository) Query() *{{ .Model.Name }}Query {
	return &{{ .Model.Name }}Query{
		Query: r.Repository.Query(),
		repo:  r,
	}
}

// QueryContext returns a type-safe query builder for {{ .Model.Name }} with context support.
// Use this when you need to control query timeouts, cancellation, or pass context values.
//
// Examples:
{{- $firstStringField := "" }}
{{- $firstBoolField := "" }}
{{- $firstTimeField := "" }}
{{- range .Model.Columns }}
{{- if and (eq .Type "string") (eq $firstStringField "") (not .IsPrimaryKey) }}{{ $firstStringField = .Name }}{{ end }}
{{- if and (eq .Type "bool") (eq $firstBoolField "") }}{{ $firstBoolField = .Name }}{{ end }}
{{- if and (eq .Type "time.Time") (eq $firstTimeField "") }}{{ $firstTimeField = .Name }}{{ end }}
{{- end }}
//   // With timeout context
//   ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
//   defer cancel()
//   results, err := repo.QueryContext(ctx).Find()
//
//   // With cancellation
//   ctx, cancel := context.WithCancel(context.Background())
//   go func() { time.Sleep(time.Second); cancel() }()
//   results, err := repo.QueryContext(ctx).Find()
//
{{- if $firstStringField }}
//   // Complex query with context
//   results, err := repo.QueryContext(ctx).
//       Where({{ .Model.Name }}s.{{ sanitizeGoName $firstStringField }}.Like("%search%")).
//       Limit(100).Find()
{{- else if $firstBoolField }}
//   // Filtered query with context
//   results, err := repo.QueryContext(ctx).
//       Where({{ .Model.Name }}s.{{ sanitizeGoName $firstBoolField }}.Eq(true)).
//       Find()
{{- else }}
//   // Simple query with context
//   results, err := repo.QueryContext(ctx).Find()
{{- end }}
func (r *{{ .Model.Name }}Repository) QueryContext(ctx context.Context) *{{ .Model.Name }}Query {
	return &{{ .Model.Name }}Query{
		Query: r.Repository.QueryContext(ctx),
		repo:  r,
	}
}

{{range .Model.Relationships}}
// With{{ .Name }} includes the {{ .Name }} relationship in queries
//
// Example:
{{- if eq .Relationship.Type "belongs_to" }}
//   {{ lower $.Model.Name }}WithOwner, err := repo.With{{ .Name }}().Find()
//   // Each {{ $.Model.Name }} will have its {{ .Name }} loaded
{{- else if eq .Relationship.Type "has_many" }}
//   {{ lower $.Model.Name }}WithAll{{ .Name }}, err := repo.With{{ .Name }}().Find()
//   // Each {{ $.Model.Name }} will have its {{ .Name }} slice populated
{{- else if eq .Relationship.Type "has_one" }}
//   {{ lower $.Model.Name }}With{{ .Name }}, err := repo.With{{ .Name }}().Find()
//   // Each {{ $.Model.Name }} will have its {{ .Name }} loaded if it exists
{{- else }}
//   {{ lower $.Model.Name }}With{{ .Name }}, err := repo.With{{ .Name }}().Find()
{{- end }}
func (r *{{ $.Model.Name }}Repository) With{{ .Name }}() *{{ $.Model.Name }}Query {
	return &{{ $.Model.Name }}Query{
		Query: r.Repository.Query().Include("{{ .Name }}"),
		repo:  r,
	}
}
{{end}}

// {{ .Model.Name }}Query provides type-safe query building for {{ .Model.Name }}
//
// Query Methods (returned by Query()):
//   - Where(condition) - Add WHERE conditions
//   - OrderBy(expressions...) - Add ORDER BY
//   - Limit(limit) - Set LIMIT
//   - Offset(offset) - Set OFFSET
//   - Join(type, table, condition) - Generic join
//   - InnerJoin(table, condition) - Inner join
//   - LeftJoin(table, condition) - Left join
//   - RightJoin(table, condition) - Right join
//   - FullJoin(table, condition) - Full outer join
//   - Include(relationships...) - Load relationships
//   - IncludeWhere(relationship, conditions...) - Load relationships with conditions
//   - WithTx(tx) - Execute within transaction
//
// Execution Methods:
//   - Find() - Execute query and return all records
//   - First() - Execute query and return first record
//   - Count() - Execute count query
//   - Exists() - Check if any records exist
//   - Delete() - Execute DELETE query
//   - ExecuteRaw(query, args...) - Execute raw SQL
//
// Example usage:
//   // Simple query
//   results, err := repo.Query().Where({{ .Model.Name }}s.FieldName.Eq("value")).Find()
//   
//   // Complex query with joins and ordering
//   results, err := repo.Query().
//       Where(condition).
//       OrderBy("created_at DESC").
//       Limit(10).
//       Find()
//   
//   // Query with relationships
//   results, err := repo.Query().
//       Include("RelationshipName").
//       Where(condition).
//       Find()
type {{ .Model.Name }}Query struct {
	*orm.Query[{{ .Model.Name }}]
	repo *{{ .Model.Name }}Repository
}

// Where applies a filtering condition to the query.
// Use the type-safe column references from {{ .Model.Name }}s for conditions.
//
// Examples:
{{- $firstStringField := "" }}
{{- $firstBoolField := "" }}
{{- $firstNumericField := "" }}
{{- $firstTimeField := "" }}
{{- range .Model.Columns }}
{{- if and (eq .Type "string") (eq $firstStringField "") (not .IsPrimaryKey) }}{{ $firstStringField = .Name }}{{ end }}
{{- if and (eq .Type "bool") (eq $firstBoolField "") }}{{ $firstBoolField = .Name }}{{ end }}
{{- if and (or (eq .Type "int") (eq .Type "int32") (eq .Type "int64")) (eq $firstNumericField "") }}{{ $firstNumericField = .Name }}{{ end }}
{{- if and (eq .Type "time.Time") (eq $firstTimeField "") }}{{ $firstTimeField = .Name }}{{ end }}
{{- end }}
{{- if $firstStringField }}
//   // Exact match
//   query.Where({{ .Model.Name }}s.{{ sanitizeGoName $firstStringField }}.Eq("exact-value"))
//   // Pattern matching
//   query.Where({{ .Model.Name }}s.{{ sanitizeGoName $firstStringField }}.Like("%search%"))
//   // Multiple values
//   query.Where({{ .Model.Name }}s.{{ sanitizeGoName $firstStringField }}.In([]string{"value1", "value2"}))
{{- end }}
{{- if $firstBoolField }}
//   // Boolean condition
//   query.Where({{ .Model.Name }}s.{{ sanitizeGoName $firstBoolField }}.Eq(true))
{{- end }}
{{- if $firstNumericField }}
//   // Numeric comparisons
//   query.Where({{ .Model.Name }}s.{{ sanitizeGoName $firstNumericField }}.Gt(100))
//   query.Where({{ .Model.Name }}s.{{ sanitizeGoName $firstNumericField }}.Between(10, 50))
{{- end }}
{{- if $firstTimeField }}
//   // Time-based queries
//   query.Where({{ .Model.Name }}s.{{ sanitizeGoName $firstTimeField }}.After(time.Now().AddDate(0, -1, 0)))
{{- end }}
//   // Combine conditions
//   query.Where({{ .Model.Name }}s.{{ sanitizeGoName (index .Model.Columns 0).Name }}.Eq("value").And({{ .Model.Name }}s.{{ sanitizeGoName (index .Model.Columns 1).Name }}.IsNotNull()))
func (q *{{ .Model.Name }}Query) Where(condition orm.Condition) *{{ .Model.Name }}Query {
	q.Query = q.Query.Where(condition)
	return q
}

// OrderBy specifies the order of results using column names or expressions.
// Use DESC suffix for descending order, ASC (or no suffix) for ascending.
//
// Examples:
{{- if $firstTimeField }}
//   // Order by time field (most recent first)
//   query.OrderBy("{{ (index .Model.Columns 0).DBName }} DESC")
{{- end }}
{{- if $firstStringField }}
//   // Order by string field alphabetically
//   query.OrderBy("{{ (index .Model.Columns 0).DBName }}")
{{- end }}
//   // Multiple columns
//   query.OrderBy("{{ (index .Model.Columns 0).DBName }} DESC", "{{ (index .Model.Columns 1).DBName }}")
//   // Complex expressions
//   query.OrderBy("CASE WHEN active THEN 0 ELSE 1 END", "created_at DESC")
func (q *{{ .Model.Name }}Query) OrderBy(expressions ...string) *{{ .Model.Name }}Query {
	q.Query = q.Query.OrderBy(expressions...)
	return q
}

// Limit restricts the number of results returned.
// Useful for pagination and preventing large result sets.
//
// Examples:
//   // Get first 10 results
//   query.Limit(10)
//   // Get top 100 most recent {{ lower .Model.Name }}s
//   query.OrderBy("created_at DESC").Limit(100)
func (q *{{ .Model.Name }}Query) Limit(limit uint64) *{{ .Model.Name }}Query {
	q.Query = q.Query.Limit(limit)
	return q
}

// Offset skips the specified number of results.
// Typically used with Limit for pagination.
//
// Examples:
//   // Skip first 20 results (page 3 with 10 per page)
//   query.Offset(20).Limit(10)
//   // Get results 51-100
//   query.Offset(50).Limit(50)
func (q *{{ .Model.Name }}Query) Offset(offset uint64) *{{ .Model.Name }}Query {
	q.Query = q.Query.Offset(offset)
	return q
}

// Find executes the query and returns all matching {{ .Model.Name }} records.
// Returns an empty slice if no records are found.
//
// Examples:
//   // Get all {{ lower .Model.Name }}s
//   all{{ .Model.Name }}s, err := repo.Query().Find()
{{- if $firstBoolField }}
//   // Get all active {{ lower .Model.Name }}s
//   active{{ .Model.Name }}s, err := repo.Query().Where({{ .Model.Name }}s.{{ sanitizeGoName $firstBoolField }}.Eq(true)).Find()
{{- end }}
{{- if $firstStringField }}
//   // Search {{ lower .Model.Name }}s by {{ lower $firstStringField }}
//   matching{{ .Model.Name }}s, err := repo.Query().Where({{ .Model.Name }}s.{{ sanitizeGoName $firstStringField }}.Like("%search%")).Find()
{{- end }}
func (q *{{ .Model.Name }}Query) Find() ([]{{ .Model.Name }}, error) {
	return q.Query.Find()
}

// First executes the query and returns the first matching {{ .Model.Name }} record.
// Returns nil if no record is found. Use with OrderBy to get specific record.
//
// Examples:
//   // Get first {{ lower .Model.Name }}
//   first{{ .Model.Name }}, err := repo.Query().First()
{{- if $firstTimeField }}
//   // Get most recent {{ lower .Model.Name }}
//   latest{{ .Model.Name }}, err := repo.Query().OrderBy("{{ $firstTimeField }} DESC").First()
{{- end }}
{{- if $firstStringField }}
//   // Get specific {{ lower .Model.Name }} by {{ lower $firstStringField }}
//   specific{{ .Model.Name }}, err := repo.Query().Where({{ .Model.Name }}s.{{ sanitizeGoName $firstStringField }}.Eq("value")).First()
{{- end }}
func (q *{{ .Model.Name }}Query) First() (*{{ .Model.Name }}, error) {
	return q.Query.First()
}

// Count returns the number of {{ .Model.Name }} records matching the query conditions.
// Does not load the actual records, making it efficient for large datasets.
//
// Examples:
//   // Count all {{ lower .Model.Name }}s
//   total, err := repo.Query().Count()
{{- if $firstBoolField }}
//   // Count active {{ lower .Model.Name }}s
//   activeCount, err := repo.Query().Where({{ .Model.Name }}s.{{ sanitizeGoName $firstBoolField }}.Eq(true)).Count()
{{- end }}
{{- if $firstStringField }}
//   // Count {{ lower .Model.Name }}s matching criteria
//   matchingCount, err := repo.Query().Where({{ .Model.Name }}s.{{ sanitizeGoName $firstStringField }}.Like("%search%")).Count()
{{- end }}
func (q *{{ .Model.Name }}Query) Count() (int64, error) {
	return q.Query.Count()
}

// Exists checks if any {{ .Model.Name }} records match the query conditions.
// Returns true if at least one record exists, false otherwise.
// More efficient than Count() when you only need to know if records exist.
//
// Examples:
//   // Check if any {{ lower .Model.Name }}s exist
//   hasAny, err := repo.Query().Exists()
{{- if $firstStringField }}
//   // Check if {{ lower .Model.Name }} with specific {{ lower $firstStringField }} exists
//   exists, err := repo.Query().Where({{ .Model.Name }}s.{{ sanitizeGoName $firstStringField }}.Eq("value")).Exists()
{{- end }}
{{- if $firstBoolField }}
//   // Check if any active {{ lower .Model.Name }}s exist
//   hasActive, err := repo.Query().Where({{ .Model.Name }}s.{{ sanitizeGoName $firstBoolField }}.Eq(true)).Exists()
{{- end }}
func (q *{{ .Model.Name }}Query) Exists() (bool, error) {
	return q.Query.Exists()
}

// Delete removes all {{ .Model.Name }} records matching the query conditions.
// Returns the number of records deleted.
// WARNING: This is a bulk operation that cannot be undone.
//
// Examples:
//   // Delete all {{ lower .Model.Name }}s (use with caution!)
//   deleted, err := repo.Query().Delete()
{{- if $firstBoolField }}
//   // Delete inactive {{ lower .Model.Name }}s
//   deleted, err := repo.Query().Where({{ .Model.Name }}s.{{ sanitizeGoName $firstBoolField }}.Eq(false)).Delete()
{{- end }}
{{- if $firstStringField }}
//   // Delete {{ lower .Model.Name }}s matching criteria
//   deleted, err := repo.Query().Where({{ .Model.Name }}s.{{ sanitizeGoName $firstStringField }}.Like("temp_%")).Delete()
{{- end }}
func (q *{{ .Model.Name }}Query) Delete() (int64, error) {
	return q.Query.Delete()
}

`

// queryTemplate is now merged with repositoryTemplate - this is kept empty for backwards compatibility
const queryTemplate = `// This template is now merged with the repository template`

// relationshipsTemplate generates relationship helper functions
const relationshipsTemplate = `//go:build !exclude_generated
// +build !exclude_generated

// Code generated by storm orm generate-orm; DO NOT EDIT.
//
// This file was automatically generated from Go struct definitions.
// Any changes made to this file will be lost when regenerating.
//
// Source package: {{ .Package }}
// Generated on: {{ .Now.Format "2006-01-02 15:04:05 MST" }}
//
// To regenerate this file, run:
//   storm orm generate-orm --package={{ .Package }}
//

package {{ .Package }}

import (
	"context"
	"database/sql"
	"fmt"
	
	orm "github.com/eleven-am/storm/pkg/storm-orm"
)

{{ range .Models }}
// {{ .Name }} relationship helpers
{{- range .Relationships }}
{{- if eq .Type "has_many" }}

// Load{{ .Name }} loads the {{ .Name }} relationship for {{ $.Name }}
func (r *{{ $.Name }}Repository) Load{{ .Name }}(ctx context.Context, entity *{{ $.Name }}) ([]{{ .Target }}, error) {
	query := "SELECT * FROM {{ .Target | lower }}s WHERE {{ .ForeignKey }} = $1"
	rows, err := r.db.QueryContext(ctx, query, entity.{{ .LocalKey }})
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	
	var results []{{ .Target }}
	for rows.Next() {
		var item {{ .Target }}
		// Scan logic would go here
		results = append(results, item)
	}
	
	return results, nil
}
{{- end }}
{{- if eq .Type "belongs_to" }}

// Load{{ .Name }} loads the {{ .Name }} relationship for {{ $.Name }}
func (r *{{ $.Name }}Repository) Load{{ .Name }}(ctx context.Context, entity *{{ $.Name }}) (*{{ .Target }}, error) {
	query := "SELECT * FROM {{ .Target | lower }}s WHERE {{ .TargetKey }} = $1"
	row := r.db.QueryRowContext(ctx, query, entity.{{ .ForeignKey }})
	
	var result {{ .Target }}
	// Scan logic would go here
	
	return &result, nil
}
{{- end }}
{{- end }}
{{ end }}
`

// stormTemplate generates the Storm struct with all repositories
const stormTemplate = `//go:build !exclude_generated
// +build !exclude_generated

// Code generated by storm orm generate-orm; DO NOT EDIT.
//
// This file was automatically generated from Go struct definitions.
// Any changes made to this file will be lost when regenerating.
//
// Source package: {{ .Package }}
// Models found: {{ len .Models }}
// Generated on: {{ .Now.Format "2006-01-02 15:04:05 MST" }}
//
// To regenerate this file, run:
//   storm orm generate-orm --package={{ .Package }}
//
// For more information, see:
//   https://github.com/eleven-am/storm

package {{ .Package }}

import (
	"context"
	"fmt"
	orm "github.com/eleven-am/storm/pkg/storm-orm"
	"github.com/jmoiron/sqlx"
)

// Storm provides a centralized access point for all repositories
// 
// Basic usage:
//   storm := NewStorm(db)
//   user, err := storm.Users.FindByID(ctx, "123")
//   users, err := storm.Users.Query().Where(Users.IsActive.Eq(true)).Find()
//
// All repositories inherit these methods from the base repository:
//
// Single Record Operations:
//   - Create(ctx, record) - Insert single record
//   - FindByID(ctx, id) - Find record by primary key
//   - Update(ctx, record) - Update single record by primary key
//   - Delete(ctx, id) - Delete record by primary key ID
//   - DeleteRecord(ctx, record) - Delete record using the record instance
//
// Batch Operations:
//   - CreateMany(ctx, records) - Insert multiple records in transaction
//   - UpdateMany(ctx, updates, condition) - Update multiple records with condition
//   - BulkUpdate(ctx, records, opts) - Bulk update using CTE with VALUES
//   - Upsert(ctx, record, opts) - Insert or update on conflict
//   - UpsertMany(ctx, records, opts) - Batch upsert operations
//
// Transaction support:
//   err := storm.WithTransaction(ctx, func(txStorm *Storm) error {
//       // All operations here run in a transaction
//       return txStorm.Users.Create(ctx, newUser)
//   })
type Storm struct {
	*orm.Storm
	
	// All repositories
	{{range $modelName, $model := .Models}}
	{{ plural $model.Name }} *{{ $model.Name }}Repository
	{{end}}
}

func NewStorm(db *sqlx.DB) *Storm {
	baseStorm := orm.NewStorm(db)
	
	storm := &Storm{
		Storm: baseStorm,
	}
	
	storm.initializeRepositories()
	
	return storm
}

func (s *Storm) WithTransaction(ctx context.Context, fn func(*Storm) error) error {
	return s.Storm.WithTransaction(ctx, func(baseStorm *orm.Storm) error {
		txStorm := &Storm{
			Storm: baseStorm,
		}
		txStorm.initializeRepositories()
		return fn(txStorm)
	})
}

func (s *Storm) WithTransactionOptions(ctx context.Context, opts *orm.TransactionOptions, fn func(*Storm) error) error {
	return s.Storm.WithTransactionOptions(ctx, opts, func(baseStorm *orm.Storm) error {
		txStorm := &Storm{
			Storm: baseStorm,
		}
		txStorm.initializeRepositories()
		return fn(txStorm)
	})
}

func (s *Storm) initializeRepositories() {
	executor := s.GetExecutor()
	
	{{range $modelName, $model := .Models}}
	if baseRepo, err := orm.NewRepositoryWithExecutor[{{ $model.Name }}](executor, {{ $model.Name }}Metadata); err == nil {
		s.{{ plural $model.Name }} = &{{ $model.Name }}Repository{
			Repository: baseRepo,
		}
	} else {
		panic(fmt.Errorf("failed to initialize {{ $model.Name }} repository: %w", err))
	}
	{{end}}
}
`
