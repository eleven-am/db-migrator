package orm_generator

// metadataTemplate generates compile-time metadata for models
const metadataTemplate = `//go:build !exclude_generated
// +build !exclude_generated

// Code generated by storm orm generate-orm; DO NOT EDIT.
//
// This file was automatically generated from Go struct definitions.
// Any changes made to this file will be lost when regenerating.
//
// Source package: {{ .Package }}
// Model: {{ .Model.Name }}
// Generated on: {{ .Now.Format "2006-01-02 15:04:05 MST" }}
//
// To regenerate this file, run:
//   storm orm generate-orm --package={{ .Package }}
//
// For more information, see:
//   https://github.com/eleven-am/storm

package {{ .Package }}

import (
	"github.com/eleven-am/storm/internal/orm"
)

// {{ .Model.Name }}Metadata provides compile-time metadata for {{ .Model.Name }}
var {{ .Model.Name }}Metadata = &orm.ModelMetadata{
	TableName:  "{{ .Model.TableName }}",
	StructName: "{{ .Model.Name }}",
	
	Columns: map[string]*orm.ColumnMetadata{
		{{- range .Model.Columns }}
		"{{ .Name }}": {
			FieldName:       "{{ .Name }}",
			DBName:          "{{ .DBName }}",
			GoType:          "{{ .Type }}",
			IsPointer:       {{ .IsPointer }},
			IsPrimaryKey:    {{ .IsPrimaryKey }},
			IsAutoGenerated: {{ .IsAutoGenerated }},
			
			// Generated accessor functions for zero-reflection field access
			GetValue: func(model interface{}) interface{} {
				m := model.({{ $.Model.Name }})
				{{- if .IsPointer }}
				if m.{{ .Name }} != nil {
					return *m.{{ .Name }}
				}
				return nil
				{{- else }}
				return m.{{ .Name }}
				{{- end }}
			},
			{{- if .IsPointer }}
			IsNil: func(model interface{}) bool {
				return model.({{ $.Model.Name }}).{{ .Name }} == nil
			},
			{{- end }}
		},
		{{- end }}
	},
	
	ColumnMap: map[string]string{
		{{- range .Model.Columns }}
		"{{ .Name }}": "{{ .DBName }}",
		{{- end }}
	},
	
	ReverseMap: map[string]string{
		{{- range .Model.Columns }}
		"{{ .DBName }}": "{{ .Name }}",
		{{- end }}
	},
	
	PrimaryKeys: []string{
		{{- range .Model.PrimaryKeys }}
		"{{ . }}",
		{{- end }}
	},
	
	Relationships: map[string]*orm.RelationshipMetadata{
		{{- range .Model.Relationships }}
		"{{ .Name }}": {
			Name:   "{{ .Name }}",
			Type:   "{{ .Relationship.Type }}",
			Target: "{{ .Relationship.Target }}",
			{{- if .Relationship.ForeignKey }}
			ForeignKey: "{{ .Relationship.ForeignKey }}",
			{{- end }}
			{{- if .Relationship.SourceKey }}
			SourceKey: "{{ .Relationship.SourceKey }}",
			{{- end }}
			{{- if .Relationship.TargetKey }}
			TargetKey: "{{ .Relationship.TargetKey }}",
			{{- end }}
			{{- if .Relationship.Through }}
			Through: "{{ .Relationship.Through }}",
			{{- end }}
			{{- if .Relationship.SourceFK }}
			ThroughFK: "{{ .Relationship.SourceFK }}",
			{{- end }}
			{{- if .Relationship.TargetFK }}
			ThroughTK: "{{ .Relationship.TargetFK }}",
			{{- end }}
			
			// Generated accessor functions for relationships
			SetValue: func(model interface{}, value interface{}) {
				{{- if .IsArray }}
				model.(*{{ $.Model.Name }}).{{ .Name }} = value.([]{{ .Relationship.Target }})
				{{- else }}
				model.(*{{ $.Model.Name }}).{{ .Name }} = value.(*{{ .Relationship.Target }})
				{{- end }}
			},
			IsSlice: {{ .IsArray }},
		},
		{{- end }}
	},
}
`

// columnTemplate generates type-safe column constants
const columnTemplate = `//go:build !exclude_generated
// +build !exclude_generated

// Code generated by storm orm generate-orm; DO NOT EDIT.
//
// This file was automatically generated from Go struct definitions.
// Any changes made to this file will be lost when regenerating.
//
// Source package: {{ .Package }}
// Models found: {{ len .Models }}
// Generated on: {{ .Now.Format "2006-01-02 15:04:05 MST" }}
//
// To regenerate this file, run:
//   storm orm generate-orm --package={{ .Package }}
//
// For more information, see:
//   https://github.com/eleven-am/storm

package {{ .Package }}

import (
	"time"
	"github.com/eleven-am/storm/internal/orm"
)

{{range $modelName, $model := .Models}}
// {{ $model.Name }}s provides type-safe column references for {{ $model.Name }}
var {{ $model.Name }}s = struct {
	{{range $model.Columns}}
	{{ sanitizeGoName .Name }} {{ if eq .Type "string" }}orm.StringColumn{{ else if eq .Type "int" }}orm.NumericColumn[int]{{ else if eq .Type "int32" }}orm.NumericColumn[int32]{{ else if eq .Type "int64" }}orm.NumericColumn[int64]{{ else if eq .Type "float32" }}orm.NumericColumn[float32]{{ else if eq .Type "float64" }}orm.NumericColumn[float64]{{ else if eq .Type "bool" }}orm.BoolColumn{{ else if eq .Type "time.Time" }}orm.TimeColumn{{ else if hasPrefix .Type "[]" }}orm.ArrayColumn[{{ .Type }}]{{ else if eq .Type "json.RawMessage" }}orm.JSONBColumn{{ else if hasPrefix .Type "JSONField[" }}orm.JSONBColumn{{ else if eq .Type "" }}orm.StringColumn{{ else }}orm.Column[interface{}]{{ end }} ` + "`json:\"{{ .DBName }}\"`" + `
	{{end}}
}{
	{{range $model.Columns}}
	{{ sanitizeGoName .Name }}: {{ if eq .Type "string" }}orm.StringColumn{Column: orm.Column[string]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}{{ else if eq .Type "int" }}orm.NumericColumn[int]{ComparableColumn: orm.ComparableColumn[int]{Column: orm.Column[int]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}}{{ else if eq .Type "int32" }}orm.NumericColumn[int32]{ComparableColumn: orm.ComparableColumn[int32]{Column: orm.Column[int32]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}}{{ else if eq .Type "int64" }}orm.NumericColumn[int64]{ComparableColumn: orm.ComparableColumn[int64]{Column: orm.Column[int64]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}}{{ else if eq .Type "float32" }}orm.NumericColumn[float32]{ComparableColumn: orm.ComparableColumn[float32]{Column: orm.Column[float32]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}}{{ else if eq .Type "float64" }}orm.NumericColumn[float64]{ComparableColumn: orm.ComparableColumn[float64]{Column: orm.Column[float64]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}}{{ else if eq .Type "bool" }}orm.BoolColumn{Column: orm.Column[bool]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}{{ else if eq .Type "time.Time" }}orm.TimeColumn{ComparableColumn: orm.ComparableColumn[time.Time]{Column: orm.Column[time.Time]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}}{{ else if hasPrefix .Type "[]" }}orm.ArrayColumn[{{ .Type }}]{Column: orm.Column[{{ .Type }}]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}{{ else if eq .Type "json.RawMessage" }}orm.JSONBColumn{Column: orm.Column[interface{}]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}{{ else if hasPrefix .Type "JSONField[" }}orm.JSONBColumn{Column: orm.Column[interface{}]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}{{ else if eq .Type "" }}orm.StringColumn{Column: orm.Column[string]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}{{ else }}orm.Column[interface{}]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}{{ end }},
	{{end}}
}

// {{ $model.Name }}Table provides table-level operations for {{ $model.Name }}
var {{ $model.Name }}Table = orm.Table{
	Name: "{{ $model.TableName }}",
	PrimaryKeys: []string{ {{ range $model.PrimaryKeys }}"{{ . }}", {{ end }} },
}

{{end}}
`

// repositoryTemplate generates repository implementations
const repositoryTemplate = `//go:build !exclude_generated
// +build !exclude_generated

// Code generated by storm orm generate-orm; DO NOT EDIT.
//
// This file was automatically generated from Go struct definitions.
// Any changes made to this file will be lost when regenerating.
//
// Source package: {{ .Package }}
// Model: {{ .Model.Name }}
// Generated on: {{ .Now.Format "2006-01-02 15:04:05 MST" }}
//
// To regenerate this file, run:
//   storm orm generate-orm --package={{ .Package }}
//
// For more information, see:
//   https://github.com/eleven-am/storm

package {{ .Package }}

import (
	"context"
	"fmt"
	"github.com/eleven-am/storm/internal/orm"
	"github.com/jmoiron/sqlx"
)

// {{ .Model.Name }}Repository provides type-safe operations for {{ .Model.Name }}
// Inherits standard CRUD operations from orm.Repository:
// Find, FindAll, Create, Update, Delete, UpsertMany, BulkUpdate, etc.
type {{ .Model.Name }}Repository struct {
	*orm.Repository[{{ .Model.Name }}]
}

func new{{ .Model.Name }}Repository(db *sqlx.DB) (*{{ .Model.Name }}Repository, error) {
	baseRepo, err := orm.NewRepository[{{ .Model.Name }}](db, {{ .Model.Name }}Metadata)
	if err != nil {
		return nil, fmt.Errorf("failed to create base repository: %w", err)
	}

	return &{{ .Model.Name }}Repository{
		Repository: baseRepo,
	}, nil
}

func new{{ .Model.Name }}RepositoryWithTx(tx *sqlx.Tx) (*{{ .Model.Name }}Repository, error) {
	baseRepo, err := orm.NewRepositoryWithTx[{{ .Model.Name }}](tx, {{ .Model.Name }}Metadata)
	if err != nil {
		return nil, fmt.Errorf("failed to create base repository with transaction: %w", err)
	}

	return &{{ .Model.Name }}Repository{
		Repository: baseRepo,
	}, nil
}

// Query returns a type-safe query builder for {{ .Model.Name }}
//
// Example:
{{- $firstStringField := "" }}
{{- $firstBoolField := "" }}
{{- $firstTimeField := "" }}
{{- $primaryKeyField := "" }}
{{- range .Model.Columns }}
{{- if and (eq .Type "string") (eq $firstStringField "") (not .IsPrimaryKey) }}{{ $firstStringField = .Name }}{{ end }}
{{- if and (eq .Type "bool") (eq $firstBoolField "") }}{{ $firstBoolField = .Name }}{{ end }}
{{- if and (eq .Type "time.Time") (eq $firstTimeField "") (not (contains .Name "At")) }}{{ $firstTimeField = .Name }}{{ end }}
{{- if and .IsPrimaryKey (eq $primaryKeyField "") }}{{ $primaryKeyField = .Name }}{{ end }}
{{- end }}
{{- if $firstBoolField }}
//   active{{ .Model.Name }}s, err := repo.Query().
//       Where({{ .Model.Name }}s.{{ sanitizeGoName $firstBoolField }}.Eq(true)).
{{- else if $firstStringField }}
//   filtered{{ .Model.Name }}s, err := repo.Query().
//       Where({{ .Model.Name }}s.{{ sanitizeGoName $firstStringField }}.Like("%search%")).
{{- else }}
//   all{{ .Model.Name }}s, err := repo.Query().
{{- end }}
{{- if $firstTimeField }}
//       OrderBy({{ .Model.Name }}s.{{ sanitizeGoName $firstTimeField }}.Desc()).
{{- else if $primaryKeyField }}
//       OrderBy({{ .Model.Name }}s.{{ sanitizeGoName $primaryKeyField }}.Desc()).
{{- else }}
//       OrderBy("id DESC").
{{- end }}
func (r *{{ .Model.Name }}Repository) Query() *{{ .Model.Name }}Query {
	return &{{ .Model.Name }}Query{
		Query: r.Repository.Query(),
		repo:  r,
	}
}

func (r *{{ .Model.Name }}Repository) QueryContext(ctx context.Context) *{{ .Model.Name }}Query {
	return &{{ .Model.Name }}Query{
		Query: r.Repository.QueryContext(ctx),
		repo:  r,
	}
}

{{range .Model.Relationships}}
// With{{ .Name }} includes the {{ .Name }} relationship in queries
//
// Example:
{{- if eq .Relationship.Type "belongs_to" }}
//   {{ lower $.Model.Name }}WithOwner, err := repo.With{{ .Name }}().Find()
//   // Each {{ $.Model.Name }} will have its {{ .Name }} loaded
{{- else if eq .Relationship.Type "has_many" }}
//   {{ lower $.Model.Name }}WithAll{{ .Name }}, err := repo.With{{ .Name }}().Find()
//   // Each {{ $.Model.Name }} will have its {{ .Name }} slice populated
{{- else if eq .Relationship.Type "has_one" }}
//   {{ lower $.Model.Name }}With{{ .Name }}, err := repo.With{{ .Name }}().Find()
//   // Each {{ $.Model.Name }} will have its {{ .Name }} loaded if it exists
{{- else }}
//   {{ lower $.Model.Name }}With{{ .Name }}, err := repo.With{{ .Name }}().Find()
{{- end }}
func (r *{{ $.Model.Name }}Repository) With{{ .Name }}() *{{ $.Model.Name }}Query {
	return &{{ $.Model.Name }}Query{
		Query: r.Repository.Query().Include("{{ .Name }}"),
		repo:  r,
	}
}
{{end}}

// {{ .Model.Name }}Query provides type-safe query building for {{ .Model.Name }}
type {{ .Model.Name }}Query struct {
	*orm.Query[{{ .Model.Name }}]
	repo *{{ .Model.Name }}Repository
}

func (q *{{ .Model.Name }}Query) Where(condition orm.Condition) *{{ .Model.Name }}Query {
	q.Query = q.Query.Where(condition)
	return q
}

func (q *{{ .Model.Name }}Query) OrderBy(expressions ...string) *{{ .Model.Name }}Query {
	q.Query = q.Query.OrderBy(expressions...)
	return q
}

func (q *{{ .Model.Name }}Query) Limit(limit uint64) *{{ .Model.Name }}Query {
	q.Query = q.Query.Limit(limit)
	return q
}

func (q *{{ .Model.Name }}Query) Offset(offset uint64) *{{ .Model.Name }}Query {
	q.Query = q.Query.Offset(offset)
	return q
}

func (q *{{ .Model.Name }}Query) Find() ([]{{ .Model.Name }}, error) {
	return q.Query.Find()
}

func (q *{{ .Model.Name }}Query) First() (*{{ .Model.Name }}, error) {
	return q.Query.First()
}

func (q *{{ .Model.Name }}Query) Count() (int64, error) {
	return q.Query.Count()
}

func (q *{{ .Model.Name }}Query) Exists() (bool, error) {
	return q.Query.Exists()
}

func (q *{{ .Model.Name }}Query) Delete() (int64, error) {
	return q.Query.Delete()
}

`

// queryTemplate is now merged with repositoryTemplate - this is kept empty for backwards compatibility
const queryTemplate = `// This template is now merged with the repository template`

// relationshipsTemplate generates relationship helper functions
const relationshipsTemplate = `//go:build !exclude_generated
// +build !exclude_generated

// Code generated by storm orm generate-orm; DO NOT EDIT.
//
// This file was automatically generated from Go struct definitions.
// Any changes made to this file will be lost when regenerating.
//
// Source package: {{ .Package }}
// Generated on: {{ .Now.Format "2006-01-02 15:04:05 MST" }}
//
// To regenerate this file, run:
//   storm orm generate-orm --package={{ .Package }}
//

package {{ .Package }}

import (
	"context"
	"database/sql"
	"fmt"
	
	"github.com/eleven-am/storm/internal/orm"
)

{{ range .Models }}
// {{ .Name }} relationship helpers
{{- range .Relationships }}
{{- if eq .Type "has_many" }}

// Load{{ .Name }} loads the {{ .Name }} relationship for {{ $.Name }}
func (r *{{ $.Name }}Repository) Load{{ .Name }}(ctx context.Context, entity *{{ $.Name }}) ([]{{ .Target }}, error) {
	query := "SELECT * FROM {{ .Target | lower }}s WHERE {{ .ForeignKey }} = $1"
	rows, err := r.db.QueryContext(ctx, query, entity.{{ .LocalKey }})
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	
	var results []{{ .Target }}
	for rows.Next() {
		var item {{ .Target }}
		// Scan logic would go here
		results = append(results, item)
	}
	
	return results, nil
}
{{- end }}
{{- if eq .Type "belongs_to" }}

// Load{{ .Name }} loads the {{ .Name }} relationship for {{ $.Name }}
func (r *{{ $.Name }}Repository) Load{{ .Name }}(ctx context.Context, entity *{{ $.Name }}) (*{{ .Target }}, error) {
	query := "SELECT * FROM {{ .Target | lower }}s WHERE {{ .TargetKey }} = $1"
	row := r.db.QueryRowContext(ctx, query, entity.{{ .ForeignKey }})
	
	var result {{ .Target }}
	// Scan logic would go here
	
	return &result, nil
}
{{- end }}
{{- end }}
{{ end }}
`

// stormTemplate generates the Storm struct with all repositories
const stormTemplate = `//go:build !exclude_generated
// +build !exclude_generated

// Code generated by storm orm generate-orm; DO NOT EDIT.
//
// This file was automatically generated from Go struct definitions.
// Any changes made to this file will be lost when regenerating.
//
// Source package: {{ .Package }}
// Models found: {{ len .Models }}
// Generated on: {{ .Now.Format "2006-01-02 15:04:05 MST" }}
//
// To regenerate this file, run:
//   storm orm generate-orm --package={{ .Package }}
//
// For more information, see:
//   https://github.com/eleven-am/storm

package {{ .Package }}

import (
	"context"
	"fmt"
	"github.com/eleven-am/storm/internal/orm"
	"github.com/jmoiron/sqlx"
)

// Storm provides a centralized access point for all repositories
// 
// Basic usage:
//   storm := NewStorm(db)
//   user, err := storm.Users.FindByID(ctx, "123")
//   users, err := storm.Users.Query().Where(Users.IsActive.Eq(true)).Find()
//
// All repositories inherit these methods from the base repository:
//   - Find(ctx, id) - Find a single record by primary key
//   - FindAll(ctx) - Find all records
//   - Create(ctx, model) - Create a new record
//   - Update(ctx, model) - Update an existing record
//   - Delete(ctx, id) - Delete a record by primary key
//   - UpsertMany(ctx, records, options) - Bulk upsert with conflict resolution
//   - BulkUpdate(ctx, records, options) - Update multiple records efficiently
//
// Transaction support:
//   err := storm.WithTransaction(ctx, func(txStorm *Storm) error {
//       // All operations here run in a transaction
//       return txStorm.Users.Create(ctx, newUser)
//   })
type Storm struct {
	*orm.Storm
	
	// All repositories
	{{range $modelName, $model := .Models}}
	{{ plural $model.Name }} *{{ $model.Name }}Repository
	{{end}}
}

func NewStorm(db *sqlx.DB) *Storm {
	baseStorm := orm.NewStorm(db)
	
	storm := &Storm{
		Storm: baseStorm,
	}
	
	storm.initializeRepositories()
	
	return storm
}

func (s *Storm) WithTransaction(ctx context.Context, fn func(*Storm) error) error {
	return s.Storm.WithTransaction(ctx, func(baseStorm *orm.Storm) error {
		txStorm := &Storm{
			Storm: baseStorm,
		}
		txStorm.initializeRepositories()
		return fn(txStorm)
	})
}

func (s *Storm) WithTransactionOptions(ctx context.Context, opts *orm.TransactionOptions, fn func(*Storm) error) error {
	return s.Storm.WithTransactionOptions(ctx, opts, func(baseStorm *orm.Storm) error {
		txStorm := &Storm{
			Storm: baseStorm,
		}
		txStorm.initializeRepositories()
		return fn(txStorm)
	})
}

func (s *Storm) initializeRepositories() {
	executor := s.GetExecutor()
	
	{{range $modelName, $model := .Models}}
	if baseRepo, err := orm.NewRepositoryWithExecutor[{{ $model.Name }}](executor, {{ $model.Name }}Metadata); err == nil {
		s.{{ plural $model.Name }} = &{{ $model.Name }}Repository{
			Repository: baseRepo,
		}
	} else {
		panic(fmt.Errorf("failed to initialize {{ $model.Name }} repository: %w", err))
	}
	{{end}}
}
`
