package orm_generator

// columnTemplate generates type-safe column constants
const columnTemplate = `// Code generated by Storm ORM generator. DO NOT EDIT.
// Generated at: {{ .Now.Format "2006-01-02 15:04:05" }}

package {{ .Package }}

import (
	"time"
	"github.com/eleven-am/storm/internal/orm"
)

{{range $modelName, $model := .Models}}
// {{ $model.Name }}s provides type-safe column references for {{ $model.Name }}
var {{ $model.Name }}s = struct {
	{{range $model.Columns}}
	{{ sanitizeGoName .Name }} {{ if eq .Type "string" }}orm.StringColumn{{ else if eq .Type "int" }}orm.NumericColumn[int]{{ else if eq .Type "int32" }}orm.NumericColumn[int32]{{ else if eq .Type "int64" }}orm.NumericColumn[int64]{{ else if eq .Type "float32" }}orm.NumericColumn[float32]{{ else if eq .Type "float64" }}orm.NumericColumn[float64]{{ else if eq .Type "bool" }}orm.BoolColumn{{ else if eq .Type "time.Time" }}orm.TimeColumn{{ else if hasPrefix .Type "[]" }}orm.ArrayColumn[{{ .Type }}]{{ else if eq .Type "json.RawMessage" }}orm.JSONBColumn{{ else if hasPrefix .Type "JSONField[" }}orm.JSONBColumn{{ else if eq .Type "" }}orm.StringColumn{{ else }}orm.Column[interface{}]{{ end }} ` + "`json:\"{{ .DBName }}\"`" + `
	{{end}}
}{
	{{range $model.Columns}}
	{{ sanitizeGoName .Name }}: {{ if eq .Type "string" }}orm.StringColumn{Column: orm.Column[string]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}{{ else if eq .Type "int" }}orm.NumericColumn[int]{ComparableColumn: orm.ComparableColumn[int]{Column: orm.Column[int]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}}{{ else if eq .Type "int32" }}orm.NumericColumn[int32]{ComparableColumn: orm.ComparableColumn[int32]{Column: orm.Column[int32]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}}{{ else if eq .Type "int64" }}orm.NumericColumn[int64]{ComparableColumn: orm.ComparableColumn[int64]{Column: orm.Column[int64]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}}{{ else if eq .Type "float32" }}orm.NumericColumn[float32]{ComparableColumn: orm.ComparableColumn[float32]{Column: orm.Column[float32]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}}{{ else if eq .Type "float64" }}orm.NumericColumn[float64]{ComparableColumn: orm.ComparableColumn[float64]{Column: orm.Column[float64]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}}{{ else if eq .Type "bool" }}orm.BoolColumn{Column: orm.Column[bool]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}{{ else if eq .Type "time.Time" }}orm.TimeColumn{ComparableColumn: orm.ComparableColumn[time.Time]{Column: orm.Column[time.Time]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}}{{ else if hasPrefix .Type "[]" }}orm.ArrayColumn[{{ .Type }}]{Column: orm.Column[{{ .Type }}]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}{{ else if eq .Type "json.RawMessage" }}orm.JSONBColumn{Column: orm.Column[interface{}]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}{{ else if hasPrefix .Type "JSONField[" }}orm.JSONBColumn{Column: orm.Column[interface{}]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}{{ else if eq .Type "" }}orm.StringColumn{Column: orm.Column[string]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}{{ else }}orm.Column[interface{}]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}{{ end }},
	{{end}}
}

// {{ $model.Name }}Table provides table-level operations for {{ $model.Name }}
var {{ $model.Name }}Table = orm.Table{
	Name: "{{ $model.TableName }}",
	PrimaryKeys: []string{ {{ range $model.PrimaryKeys }}"{{ . }}", {{ end }} },
}

{{end}}
`

// repositoryTemplate generates repository implementations
const repositoryTemplate = `// Code generated by Storm ORM generator. DO NOT EDIT.
// Generated at: {{ .Now.Format "2006-01-02 15:04:05" }}

package {{ .Package }}

import (
	"context"
	"fmt"
	"github.com/eleven-am/storm/internal/orm"
	"github.com/jmoiron/sqlx"
)

// {{ .Model.Name }}Repository provides type-safe operations for {{ .Model.Name }}
type {{ .Model.Name }}Repository struct {
	*orm.Repository[{{ .Model.Name }}]
}

// new{{ .Model.Name }}Repository creates a new {{ .Model.Name }} repository (internal use only - use Storm)
func new{{ .Model.Name }}Repository(db *sqlx.DB) (*{{ .Model.Name }}Repository, error) {
	baseRepo, err := orm.NewRepository[{{ .Model.Name }}](db)
	if err != nil {
		return nil, fmt.Errorf("failed to create base repository: %w", err)
	}

	return &{{ .Model.Name }}Repository{
		Repository: baseRepo,
	}, nil
}

// new{{ .Model.Name }}RepositoryWithTx creates a new {{ .Model.Name }} repository using an existing transaction (internal use only - use Storm)
func new{{ .Model.Name }}RepositoryWithTx(tx *sqlx.Tx) (*{{ .Model.Name }}Repository, error) {
	baseRepo, err := orm.NewRepositoryWithTx[{{ .Model.Name }}](tx)
	if err != nil {
		return nil, fmt.Errorf("failed to create base repository with transaction: %w", err)
	}

	return &{{ .Model.Name }}Repository{
		Repository: baseRepo,
	}, nil
}

// Query returns a type-safe query builder for {{ .Model.Name }}
func (r *{{ .Model.Name }}Repository) Query() *{{ .Model.Name }}Query {
	return &{{ .Model.Name }}Query{
		Query: r.Repository.Query(),
		repo:  r,
	}
}

// QueryContext returns a type-safe query builder for {{ .Model.Name }} with context
func (r *{{ .Model.Name }}Repository) QueryContext(ctx context.Context) *{{ .Model.Name }}Query {
	return &{{ .Model.Name }}Query{
		Query: r.Repository.QueryContext(ctx),
		repo:  r,
	}
}

{{range .Model.Relationships}}
// With{{ .Name }} includes the {{ .Name }} relationship in queries
func (r *{{ $.Model.Name }}Repository) With{{ .Name }}() *{{ $.Model.Name }}Query {
	return &{{ $.Model.Name }}Query{
		Query: r.Repository.Query().Include("{{ .Name }}"),
		repo:  r,
	}
}
{{end}}

// Domain-specific finder methods
{{range .Model.Columns}}
{{if .IsUnique}}
// FindBy{{ .Name }} finds a {{ $.Model.Name }} by {{ .Name }}
func (r *{{ $.Model.Name }}Repository) FindBy{{ .Name }}(ctx context.Context, value {{ .Type }}) (*{{ $.Model.Name }}, error) {
	return r.QueryContext(ctx).Where({{ $.Model.Name }}s.{{ sanitizeGoName .Name }}.Eq(value)).First()
}
{{end}}
{{end}}

{{range .Model.Columns}}
{{if and (eq .Type "bool") (not .IsPointer)}}
// FindWhere{{ .Name }} finds {{ $.Model.Name }} records where {{ .Name }} is true/false
func (r *{{ $.Model.Name }}Repository) FindWhere{{ .Name }}(ctx context.Context, value bool) ([]{{ $.Model.Name }}, error) {
	return r.QueryContext(ctx).Where({{ $.Model.Name }}s.{{ sanitizeGoName .Name }}.Eq(value)).Find()
}
{{end}}
{{end}}

{{range .Model.Columns}}
{{if and (eq .Type "string") (not .IsPointer)}}
// FindBy{{ .Name }}Like finds {{ $.Model.Name }} records where {{ .Name }} matches pattern
func (r *{{ $.Model.Name }}Repository) FindBy{{ .Name }}Like(ctx context.Context, pattern string) ([]{{ $.Model.Name }}, error) {
	return r.QueryContext(ctx).Where({{ $.Model.Name }}s.{{ sanitizeGoName .Name }}.Like(pattern)).Find()
}
{{end}}
{{end}}

// Batch operations (available methods from base repository)
// - UpsertMany: bulk upsert with ON CONFLICT resolution
// - BulkUpdate: update multiple records with different values
// Usage examples:
//   repo.UpsertMany(records, orm.UpsertOptions{ConflictColumns: []string{"id"}})
//   repo.BulkUpdate(records, orm.BulkUpdateOptions{})
`

// queryTemplate generates query builder implementations
const queryTemplate = `// Code generated by Storm ORM generator. DO NOT EDIT.
// Generated at: {{ .Now.Format "2006-01-02 15:04:05" }}

package {{ .Package }}

import (
	"time"
	"github.com/eleven-am/storm/internal/orm"
)

// {{ .Model.Name }}Query provides type-safe query building for {{ .Model.Name }}
type {{ .Model.Name }}Query struct {
	*orm.Query[{{ .Model.Name }}]
	repo *{{ .Model.Name }}Repository
}

// Where adds a type-safe WHERE condition
func (q *{{ .Model.Name }}Query) Where(condition orm.Condition) *{{ .Model.Name }}Query {
	q.Query = q.Query.Where(condition)
	return q
}

// OrderBy adds ordering to the query
func (q *{{ .Model.Name }}Query) OrderBy(expressions ...string) *{{ .Model.Name }}Query {
	q.Query = q.Query.OrderBy(expressions...)
	return q
}

// Limit sets the LIMIT clause
func (q *{{ .Model.Name }}Query) Limit(limit uint64) *{{ .Model.Name }}Query {
	q.Query = q.Query.Limit(limit)
	return q
}

// Offset sets the OFFSET clause
func (q *{{ .Model.Name }}Query) Offset(offset uint64) *{{ .Model.Name }}Query {
	q.Query = q.Query.Offset(offset)
	return q
}

{{range .Model.Relationships}}
// Include{{ .Name }} includes the {{ .Name }} relationship
func (q *{{ $.Model.Name }}Query) Include{{ .Name }}() *{{ $.Model.Name }}Query {
	q.Query = q.Query.Include("{{ .Name }}")
	return q
}
{{end}}

// Type-safe column-specific query methods
{{range .Model.Columns}}
{{if eq .Type "string"}}
// Where{{ .Name }}Eq adds WHERE {{ .DBName }} = condition
func (q *{{ $.Model.Name }}Query) Where{{ .Name }}Eq(value {{ .Type }}) *{{ $.Model.Name }}Query {
	return q.Where({{ $.Model.Name }}s.{{ sanitizeGoName .Name }}.Eq(value))
}

// Where{{ .Name }}Like adds WHERE {{ .DBName }} LIKE condition
func (q *{{ $.Model.Name }}Query) Where{{ .Name }}Like(pattern string) *{{ $.Model.Name }}Query {
	return q.Where({{ $.Model.Name }}s.{{ sanitizeGoName .Name }}.Like(pattern))
}

{{end}}

{{if or (eq .Type "int") (eq .Type "int32") (eq .Type "int64") (eq .Type "float32") (eq .Type "float64")}}
// Where{{ .Name }}Eq adds WHERE {{ .DBName }} = condition
func (q *{{ $.Model.Name }}Query) Where{{ .Name }}Eq(value {{ .Type }}) *{{ $.Model.Name }}Query {
	return q.Where({{ $.Model.Name }}s.{{ sanitizeGoName .Name }}.Eq(value))
}

// Where{{ .Name }}Gt adds WHERE {{ .DBName }} > condition
func (q *{{ $.Model.Name }}Query) Where{{ .Name }}Gt(value {{ .Type }}) *{{ $.Model.Name }}Query {
	return q.Where({{ $.Model.Name }}s.{{ sanitizeGoName .Name }}.Gt(value))
}

// Where{{ .Name }}Gte adds WHERE {{ .DBName }} >= condition
func (q *{{ $.Model.Name }}Query) Where{{ .Name }}Gte(value {{ .Type }}) *{{ $.Model.Name }}Query {
	return q.Where({{ $.Model.Name }}s.{{ sanitizeGoName .Name }}.Gte(value))
}

// Where{{ .Name }}Lt adds WHERE {{ .DBName }} < condition
func (q *{{ $.Model.Name }}Query) Where{{ .Name }}Lt(value {{ .Type }}) *{{ $.Model.Name }}Query {
	return q.Where({{ $.Model.Name }}s.{{ sanitizeGoName .Name }}.Lt(value))
}

// Where{{ .Name }}Lte adds WHERE {{ .DBName }} <= condition
func (q *{{ $.Model.Name }}Query) Where{{ .Name }}Lte(value {{ .Type }}) *{{ $.Model.Name }}Query {
	return q.Where({{ $.Model.Name }}s.{{ sanitizeGoName .Name }}.Lte(value))
}

// Where{{ .Name }}Between adds WHERE {{ .DBName }} BETWEEN condition
func (q *{{ $.Model.Name }}Query) Where{{ .Name }}Between(min, max {{ .Type }}) *{{ $.Model.Name }}Query {
	return q.Where({{ $.Model.Name }}s.{{ sanitizeGoName .Name }}.Between(min, max))
}
{{end}}

{{if eq .Type "bool"}}
// Where{{ .Name }}Eq adds WHERE {{ .DBName }} = condition
func (q *{{ $.Model.Name }}Query) Where{{ .Name }}Eq(value bool) *{{ $.Model.Name }}Query {
	return q.Where({{ $.Model.Name }}s.{{ sanitizeGoName .Name }}.Eq(value))
}

// Where{{ .Name }}IsTrue adds WHERE {{ .DBName }} = true condition
func (q *{{ $.Model.Name }}Query) Where{{ .Name }}IsTrue() *{{ $.Model.Name }}Query {
	return q.Where({{ $.Model.Name }}s.{{ sanitizeGoName .Name }}.Eq(true))
}

// Where{{ .Name }}IsFalse adds WHERE {{ .DBName }} = false condition
func (q *{{ $.Model.Name }}Query) Where{{ .Name }}IsFalse() *{{ $.Model.Name }}Query {
	return q.Where({{ $.Model.Name }}s.{{ sanitizeGoName .Name }}.Eq(false))
}
{{end}}

{{if eq .Type "time.Time"}}
// Where{{ .Name }}Eq adds WHERE {{ .DBName }} = condition
func (q *{{ $.Model.Name }}Query) Where{{ .Name }}Eq(value time.Time) *{{ $.Model.Name }}Query {
	return q.Where({{ $.Model.Name }}s.{{ sanitizeGoName .Name }}.Eq(value))
}

// Where{{ .Name }}After adds WHERE {{ .DBName }} > condition
func (q *{{ $.Model.Name }}Query) Where{{ .Name }}After(value time.Time) *{{ $.Model.Name }}Query {
	return q.Where({{ $.Model.Name }}s.{{ sanitizeGoName .Name }}.Gt(value))
}

// Where{{ .Name }}Before adds WHERE {{ .DBName }} < condition
func (q *{{ $.Model.Name }}Query) Where{{ .Name }}Before(value time.Time) *{{ $.Model.Name }}Query {
	return q.Where({{ $.Model.Name }}s.{{ sanitizeGoName .Name }}.Lt(value))
}

// Where{{ .Name }}Between adds WHERE {{ .DBName }} BETWEEN condition
func (q *{{ $.Model.Name }}Query) Where{{ .Name }}Between(start, end time.Time) *{{ $.Model.Name }}Query {
	return q.Where({{ $.Model.Name }}s.{{ sanitizeGoName .Name }}.Between(start, end))
}
{{end}}

{{if .IsPointer}}
// Where{{ .Name }}IsNull adds WHERE {{ .DBName }} IS NULL condition
func (q *{{ $.Model.Name }}Query) Where{{ .Name }}IsNull() *{{ $.Model.Name }}Query {
	return q.Where({{ $.Model.Name }}s.{{ sanitizeGoName .Name }}.IsNull())
}

// Where{{ .Name }}IsNotNull adds WHERE {{ .DBName }} IS NOT NULL condition
func (q *{{ $.Model.Name }}Query) Where{{ .Name }}IsNotNull() *{{ $.Model.Name }}Query {
	return q.Where({{ $.Model.Name }}s.{{ sanitizeGoName .Name }}.IsNotNull())
}
{{end}}
{{end}}

// Ordering methods
{{range .Model.Columns}}
// OrderBy{{ .Name }}Asc adds ORDER BY {{ .DBName }} ASC
func (q *{{ $.Model.Name }}Query) OrderBy{{ .Name }}Asc() *{{ $.Model.Name }}Query {
	return q.OrderBy({{ $.Model.Name }}s.{{ sanitizeGoName .Name }}.Asc())
}

// OrderBy{{ .Name }}Desc adds ORDER BY {{ .DBName }} DESC
func (q *{{ $.Model.Name }}Query) OrderBy{{ .Name }}Desc() *{{ $.Model.Name }}Query {
	return q.OrderBy({{ $.Model.Name }}s.{{ sanitizeGoName .Name }}.Desc())
}
{{end}}


// Execution methods return the underlying Query methods
func (q *{{ .Model.Name }}Query) Find() ([]{{ .Model.Name }}, error) {
	return q.Query.Find()
}

func (q *{{ .Model.Name }}Query) First() (*{{ .Model.Name }}, error) {
	return q.Query.First()
}

func (q *{{ .Model.Name }}Query) Count() (int64, error) {
	return q.Query.Count()
}

func (q *{{ .Model.Name }}Query) Exists() (bool, error) {
	return q.Query.Exists()
}

func (q *{{ .Model.Name }}Query) Delete() (int64, error) {
	return q.Query.Delete()
}
`

// relationshipTemplate generates relationship helper code
const relationshipTemplate = `// Code generated by Storm ORM generator. DO NOT EDIT.
// Generated at: {{ .Now.Format "2006-01-02 15:04:05" }}

package {{ .Package }}

import (
	"context"
)

{{range $modelName, $model := .Models}}
{{range $model.Relationships}}
// load{{ .Name }}For{{ $model.Name }} loads {{ .Name }} relationship for multiple {{ $model.Name }} records (internal use only)
func load{{ .Name }}For{{ $model.Name }}(ctx context.Context, records []{{ $model.Name }}) error {
	if len(records) == 0 {
		return nil
	}

	{{if eq .Relationship.Type "belongs_to"}}
	// Extract foreign key values for belongs_to relationship
	var foreignKeys []interface{}
	keyMap := make(map[interface{}][]{{ $model.Name }})
	
	for _, record := range records {
		// Get foreign key value from record.{{ .Relationship.ForeignKey }}
		// This would need reflection in real implementation
		// For now, placeholder implementation
		_ = record // suppress unused warning
	}
	_ = foreignKeys // suppress unused warning
	_ = keyMap      // suppress unused warning
	
	// Load related records
	// relatedRecords := Load{{ .Relationship.Target }}ByKeys(ctx, foreignKeys)
	
	// Assign to records
	// Implementation details...
	{{else if eq .Relationship.Type "has_one"}}
	// Extract source key values for has_one relationship
	var sourceKeys []interface{}
	keyMap := make(map[interface{}]{{ $model.Name }})
	
	for _, record := range records {
		// Get source key value from record.{{ .Relationship.SourceKey }}
		// This would need reflection in real implementation
		_ = record // suppress unused warning
	}
	_ = sourceKeys // suppress unused warning
	_ = keyMap     // suppress unused warning
	
	// Load related records where foreign_key IN (sourceKeys)
	// Implementation details...
	{{else if eq .Relationship.Type "has_many"}}
	// Extract source key values for has_many relationship
	var sourceKeys []interface{}
	keyMap := make(map[interface{}][]{{ $model.Name }})
	
	for _, record := range records {
		// Get source key value from record.{{ .Relationship.SourceKey }}
		// This would need reflection in real implementation
		_ = record // suppress unused warning
	}
	_ = sourceKeys // suppress unused warning
	_ = keyMap     // suppress unused warning
	
	// Load related records where foreign_key IN (sourceKeys)
	// Group by foreign key and assign to records
	// Implementation details...
	{{else if eq .Relationship.Type "has_many_through"}}
	// Extract source key values for has_many_through relationship
	var sourceKeys []interface{}
	keyMap := make(map[interface{}][]{{ $model.Name }})
	
	for _, record := range records {
		// Get source key value from record.{{ .Relationship.SourceKey }}
		// This would need reflection in real implementation
		_ = record // suppress unused warning
	}
	_ = sourceKeys // suppress unused warning
	_ = keyMap     // suppress unused warning
	
	// Load through join table: {{ .Relationship.JoinTable }}
	// Join with target table: {{ .Relationship.Target }}
	// Implementation details...
	{{else}}
	return fmt.Errorf("unsupported relationship type: {{ .Relationship.Type }}")
	{{end}}
	
	return nil
}

{{end}}
{{end}}
`

// stormTemplate generates the Storm struct with all repositories
const stormTemplate = `// Code generated by Storm ORM generator. DO NOT EDIT.
// Generated at: {{ .Now.Format "2006-01-02 15:04:05" }}

package {{ .Package }}

import (
	"context"
	"fmt"
	"github.com/eleven-am/storm/internal/orm"
	"github.com/jmoiron/sqlx"
)

// Storm provides a centralized access point for all repositories
type Storm struct {
	*orm.Storm
	
	// All repositories
	{{range $modelName, $model := .Models}}
	{{ $model.Name }}s *{{ $model.Name }}Repository
	{{end}}
}

// NewStorm creates a new Storm instance with all repositories initialized
func NewStorm(db *sqlx.DB) *Storm {
	// Create base Storm
	baseStorm := orm.NewStorm(db)
	
	// Create our Storm with embedded base
	storm := &Storm{
		Storm: baseStorm,
	}
	
	// Initialize repositories
	storm.initializeRepositories()
	
	return storm
}

// WithTransaction executes a function within a database transaction
// It returns a transaction-aware Storm instance to the callback
func (s *Storm) WithTransaction(ctx context.Context, fn func(*Storm) error) error {
	return s.Storm.WithTransaction(ctx, func(baseStorm *orm.Storm) error {
		// Create transaction Storm with same embedded base
		txStorm := &Storm{
			Storm: baseStorm,
		}
		// Initialize repositories with transaction executor
		txStorm.initializeRepositories()
		return fn(txStorm)
	})
}

// WithTransactionOptions executes a function within a database transaction with options
func (s *Storm) WithTransactionOptions(ctx context.Context, opts *orm.TransactionOptions, fn func(*Storm) error) error {
	return s.Storm.WithTransactionOptions(ctx, opts, func(baseStorm *orm.Storm) error {
		// Create transaction Storm with same embedded base
		txStorm := &Storm{
			Storm: baseStorm,
		}
		// Initialize repositories with transaction executor
		txStorm.initializeRepositories()
		return fn(txStorm)
	})
}

// initializeRepositories initializes all repository instances
func (s *Storm) initializeRepositories() {
	executor := s.GetExecutor()
	
	{{range $modelName, $model := .Models}}
	// Initialize {{ $model.Name }} repository
	if baseRepo, err := orm.NewRepositoryWithExecutor[{{ $model.Name }}](executor); err == nil {
		s.{{ $model.Name }}s = &{{ $model.Name }}Repository{
			Repository: baseRepo,
		}
	} else {
		panic(fmt.Errorf("failed to initialize {{ $model.Name }} repository: %w", err))
	}
	{{end}}
}
`
