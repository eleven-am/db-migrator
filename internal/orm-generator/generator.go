package orm_generator

import (
	"bytes"
	"fmt"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
	"time"

	stormParser "github.com/eleven-am/storm/internal/parser"
)

// CodeGenerator handles generation of type-safe ORM code
type CodeGenerator struct {
	tagParser   *ORMTagParser
	packageName string
	outputDir   string
	templates   map[string]*template.Template
	models      map[string]*ModelMetadata
}

// GenerationConfig configures code generation
type GenerationConfig struct {
	PackageName  string   // Package name for generated code
	OutputDir    string   // Output directory
	Models       []string // Model names to generate (empty = all)
	Features     []string // Features to generate (columns, repositories, etc.)
	TemplateDir  string   // Custom template directory
	FileHeader   string   // Custom file header
	IncludeTests bool     // Whether to generate tests
	IncludeDocs  bool     // Whether to generate documentation
}

func NewCodeGenerator(config GenerationConfig) *CodeGenerator {
	return &CodeGenerator{
		tagParser:   NewORMTagParser(),
		packageName: config.PackageName,
		outputDir:   config.OutputDir,
		templates:   make(map[string]*template.Template),
		models:      make(map[string]*ModelMetadata),
	}
}

func (g *CodeGenerator) DiscoverModels(packagePath string) error {
	if g.packageName == "" {
		packageName, err := g.detectPackageName(packagePath)
		if err != nil {
			return fmt.Errorf("failed to detect package name: %w", err)
		}
		g.packageName = packageName
	}

	structParser := stormParser.NewStructParser()
	tables, err := structParser.ParseDirectory(packagePath)
	if err != nil {
		return fmt.Errorf("failed to parse directory %s: %w", packagePath, err)
	}

	var dbModels []stormParser.TableDefinition
	for _, table := range tables {
		if _, hasExplicitTable := table.TableLevel["table"]; hasExplicitTable {
			dbModels = append(dbModels, table)
		}
	}

	for _, tableDef := range dbModels {
		metadata := g.convertTableDefinitionToModelMetadata(tableDef)
		g.models[metadata.Name] = metadata
	}

	return nil
}

func (g *CodeGenerator) convertTableDefinitionToModelMetadata(tableDef stormParser.TableDefinition) *ModelMetadata {
	metadata := &ModelMetadata{
		Name:          tableDef.StructName,
		TableName:     tableDef.TableName,
		Columns:       make([]FieldMetadata, 0, len(tableDef.Fields)),
		PrimaryKeys:   make([]string, 0),
		Indexes:       make([]IndexMetadata, 0),
		Relationships: make([]FieldMetadata, 0),
	}

	for _, field := range tableDef.Fields {
		fieldMeta := FieldMetadata{
			Name:   field.Name,
			DBName: field.DBName,
			Type:   field.Type,
		}

		fieldMeta.IsPointer = field.IsPointer
		fieldMeta.IsArray = field.IsArray

		if field.StormTag != "" {
			parsedFieldMeta, err := g.tagParser.ParseFieldFromAST(field)
			if err != nil {
				fmt.Printf("Warning: failed to parse storm tag for field %s.%s: %v\n", tableDef.StructName, field.Name, err)
			} else if parsedFieldMeta.Relationship != nil {
				fieldMeta.Relationship = parsedFieldMeta.Relationship
				metadata.Relationships = append(metadata.Relationships, fieldMeta)
				continue
			}
		} else if field.ORMTag != "" {
			parsedRel, err := g.tagParser.ParseORMTag(field.ORMTag)
			if err != nil {
				fmt.Printf("Warning: failed to parse ORM tag for field %s.%s: %v\n", tableDef.StructName, field.Name, err)
			} else {
				fieldMeta.Relationship = parsedRel
				metadata.Relationships = append(metadata.Relationships, fieldMeta)
				continue
			}
		}

		if _, isPK := field.DBDef["primary_key"]; isPK {
			fieldMeta.IsPrimaryKey = true
			metadata.PrimaryKeys = append(metadata.PrimaryKeys, field.DBName)
		}

		if _, isUnique := field.DBDef["unique"]; isUnique {
			fieldMeta.IsUnique = true
		}

		if defaultVal, hasDefault := field.DBDef["default"]; hasDefault {
			fieldMeta.DefaultValue = defaultVal
			if isAutoGeneratedDefault(defaultVal) || field.DBDef["type"] == "serial" {
				fieldMeta.IsAutoGenerated = true
			}
		}

		if dbType, hasType := field.DBDef["type"]; hasType {
			fieldMeta.DBType = dbType
		}

		metadata.Columns = append(metadata.Columns, fieldMeta)
	}

	return metadata
}

func (g *CodeGenerator) detectPackageName(packagePath string) (string, error) {
	pattern := filepath.Join(packagePath, "*.go")
	matches, err := filepath.Glob(pattern)
	if err != nil {
		return "", fmt.Errorf("failed to glob directory %s: %w", packagePath, err)
	}

	if len(matches) == 0 {
		return "", fmt.Errorf("no Go files found in directory %s", packagePath)
	}

	fileSet := token.NewFileSet()
	for _, file := range matches {
		if strings.HasSuffix(file, "_test.go") {
			continue
		}

		src, err := parser.ParseFile(fileSet, file, nil, parser.ParseComments)
		if err != nil {
			continue
		}

		if src.Name != nil {
			return src.Name.Name, nil
		}
	}

	return "", fmt.Errorf("could not detect package name from files in %s", packagePath)
}

func (g *CodeGenerator) mapSchemaTypeToGo(schemaType string) string {
	switch strings.ToLower(schemaType) {
	case "text", "varchar", "char":
		return "string"
	case "integer", "int", "int4":
		return "int32"
	case "bigint", "int8":
		return "int64"
	case "smallint", "int2":
		return "int16"
	case "boolean", "bool":
		return "bool"
	case "timestamptz", "timestamp":
		return "time.Time"
	case "real", "float4":
		return "float32"
	case "double precision", "float8":
		return "float64"
	case "jsonb", "json":
		return "json.RawMessage"
	case "bytea":
		return "[]byte"
	default:
		if strings.HasSuffix(schemaType, "[]") {
			baseType := strings.TrimSuffix(schemaType, "[]")
			return "[]" + g.mapSchemaTypeToGo(baseType)
		}
		return "string" // Default fallback
	}
}

func (g *CodeGenerator) GenerateAll() error {
	if err := g.loadTemplates(); err != nil {
		return fmt.Errorf("failed to load templates: %w", err)
	}

	if err := g.generateMetadata(); err != nil {
		return fmt.Errorf("failed to generate metadata: %w", err)
	}

	if err := g.generateColumnConstants(); err != nil {
		return fmt.Errorf("failed to generate column constants: %w", err)
	}

	if err := g.generateRepositories(); err != nil {
		return fmt.Errorf("failed to generate repositories: %w", err)
	}

	if err := g.generateRelationships(); err != nil {
		return fmt.Errorf("failed to generate relationships: %w", err)
	}

	if err := g.generateStorm(); err != nil {
		return fmt.Errorf("failed to generate Storm: %w", err)
	}

	return nil
}

func (g *CodeGenerator) loadTemplates() error {
	funcMap := template.FuncMap{
		"lower":          strings.ToLower,
		"upper":          strings.ToUpper,
		"title":          strings.Title,
		"camel":          toCamelCase,
		"pascal":         toPascalCase,
		"snake":          toSnakeCase,
		"plural":         pluralize,
		"singular":       singularize,
		"goType":         g.mapDBTypeToGo,
		"dbType":         g.mapGoTypeToPostgreSQL,
		"join":           strings.Join,
		"hasPrefix":      strings.HasPrefix,
		"hasSuffix":      strings.HasSuffix,
		"contains":       strings.Contains,
		"replace":        strings.ReplaceAll,
		"now":            time.Now,
		"sanitizeGoName": sanitizeGoName,
	}

	g.templates["metadata"] = template.Must(template.New("metadata").Funcs(funcMap).Parse(metadataTemplate))
	g.templates["columns"] = template.Must(template.New("columns").Funcs(funcMap).Parse(columnTemplate))
	g.templates["repository"] = template.Must(template.New("repository").Funcs(funcMap).Parse(repositoryTemplate))
	g.templates["relationships"] = template.Must(template.New("relationships").Funcs(funcMap).Parse(relationshipsTemplate))
	g.templates["storm"] = template.Must(template.New("storm").Funcs(funcMap).Parse(stormTemplate))

	return nil
}

func (g *CodeGenerator) generateMetadata() error {
	for _, model := range g.models {
		hasTimeFields := false
		for _, col := range model.Columns {
			if col.Type == "time.Time" {
				hasTimeFields = true
				break
			}
		}

		data := struct {
			Package       string
			Model         *ModelMetadata
			HasTimeFields bool
			Now           time.Time
		}{
			Package:       g.packageName,
			Model:         model,
			HasTimeFields: hasTimeFields,
			Now:           time.Now(),
		}

		filename := fmt.Sprintf("%s_metadata.go", strings.ToLower(model.Name))
		if err := g.executeTemplate("metadata", filename, data); err != nil {
			return err
		}
	}
	return nil
}

func (g *CodeGenerator) generateColumnConstants() error {
	data := struct {
		Package string
		Models  map[string]*ModelMetadata
		Now     time.Time
	}{
		Package: g.packageName,
		Models:  g.models,
		Now:     time.Now(),
	}

	return g.executeTemplate("columns", "columns.go", data)
}

func (g *CodeGenerator) generateRepositories() error {
	for _, model := range g.models {
		data := struct {
			Package string
			Model   *ModelMetadata
			Now     time.Time
		}{
			Package: g.packageName,
			Model:   model,
			Now:     time.Now(),
		}

		filename := fmt.Sprintf("%s_repository.go", toSnakeCase(model.Name))
		if err := g.executeTemplate("repository", filename, data); err != nil {
			return err
		}
	}
	return nil
}

func (g *CodeGenerator) generateRelationships() error {
	data := struct {
		Package string
		Models  map[string]*ModelMetadata
		Now     time.Time
	}{
		Package: g.packageName,
		Models:  g.models,
		Now:     time.Now(),
	}

	return g.executeTemplate("relationships", "relationships.go", data)
}

func (g *CodeGenerator) generateStorm() error {
	data := struct {
		Package string
		Models  map[string]*ModelMetadata
		Now     time.Time
	}{
		Package: g.packageName,
		Models:  g.models,
		Now:     time.Now(),
	}

	return g.executeTemplate("storm", "storm.go", data)
}

func (g *CodeGenerator) executeTemplate(templateName, filename string, data interface{}) error {
	tmpl, exists := g.templates[templateName]
	if !exists {
		return fmt.Errorf("template %s not found", templateName)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("failed to execute template %s: %w", templateName, err)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("failed to format generated code for %s: %w", filename, err)
	}

	outputPath := filepath.Join(g.outputDir, filename)
	return writeFile(outputPath, formatted)
}

func (g *CodeGenerator) mapDBTypeToGo(dbType string) string {
	switch strings.ToLower(dbType) {
	case "integer", "int", "int4":
		return "int32"
	case "bigint", "int8":
		return "int64"
	case "smallint", "int2":
		return "int16"
	case "text", "varchar", "character varying":
		return "string"
	case "boolean", "bool":
		return "bool"
	case "timestamp", "timestamp with time zone", "timestamptz":
		return "time.Time"
	case "date":
		return "time.Time"
	case "real", "float4":
		return "float32"
	case "double precision", "float8":
		return "float64"
	case "uuid":
		return "string"
	case "jsonb", "json":
		return "json.RawMessage"
	case "bytea":
		return "[]byte"
	default:
		if strings.HasSuffix(dbType, "[]") {
			baseType := strings.TrimSuffix(dbType, "[]")
			return "[]" + g.mapDBTypeToGo(baseType)
		}
		return "string"
	}
}

func (g *CodeGenerator) mapGoTypeToPostgreSQL(goType string) string {
	switch goType {
	case "string":
		return "TEXT"
	case "int", "int32":
		return "INTEGER"
	case "int64":
		return "BIGINT"
	case "int16":
		return "SMALLINT"
	case "float32":
		return "REAL"
	case "float64":
		return "DOUBLE PRECISION"
	case "bool":
		return "BOOLEAN"
	case "time.Time":
		return "TIMESTAMP WITH TIME ZONE"
	case "[]byte":
		return "BYTEA"
	case "json.RawMessage":
		return "JSONB"
	default:
		if strings.HasPrefix(goType, "[]") {
			baseType := strings.TrimPrefix(goType, "[]")
			return g.mapGoTypeToPostgreSQL(baseType) + "[]"
		}
		return "TEXT"
	}
}

func writeFile(path string, content []byte) error {
	dir := filepath.Dir(path)
	if err := ensureDir(dir); err != nil {
		return fmt.Errorf("failed to create directory %s: %w", dir, err)
	}

	return os.WriteFile(path, content, 0644)
}

func ensureDir(path string) error {
	return os.MkdirAll(path, 0755)
}

func (g *CodeGenerator) GetModelNames() []string {
	names := make([]string, 0, len(g.models))
	for name := range g.models {
		names = append(names, name)
	}
	sort.Strings(names)
	return names
}

func (g *CodeGenerator) GetModel(name string) (*ModelMetadata, bool) {
	model, exists := g.models[name]
	return model, exists
}

func (g *CodeGenerator) GetModelsByTable() map[string]*ModelMetadata {
	result := make(map[string]*ModelMetadata)
	for _, model := range g.models {
		result[model.TableName] = model
	}
	return result
}

func (g *CodeGenerator) ValidateModels() error {
	for name, model := range g.models {
		if err := g.validateModel(model); err != nil {
			return fmt.Errorf("model %s validation failed: %w", name, err)
		}
	}
	return nil
}

func (g *CodeGenerator) validateModel(model *ModelMetadata) error {
	if len(model.PrimaryKeys) == 0 {
		return fmt.Errorf("model %s has no primary key", model.Name)
	}

	for _, rel := range model.Relationships {
		if err := g.validateRelationship(model, rel); err != nil {
			return fmt.Errorf("relationship %s validation failed: %w", rel.Name, err)
		}
	}

	return nil
}

func (g *CodeGenerator) validateRelationship(model *ModelMetadata, rel FieldMetadata) error {
	if rel.Relationship == nil {
		return fmt.Errorf("relationship %s has no metadata", rel.Name)
	}

	targetModel, exists := g.models[rel.Relationship.Target]
	if !exists {
		return fmt.Errorf("target model %s not found for relationship %s", rel.Relationship.Target, rel.Name)
	}

	switch rel.Relationship.Type {
	case "belongs_to":
		if !g.hasColumn(model, rel.Relationship.ForeignKey) {
			return fmt.Errorf("foreign key column %s not found in model %s", rel.Relationship.ForeignKey, model.Name)
		}
		if !g.hasColumn(targetModel, rel.Relationship.TargetKey) {
			return fmt.Errorf("target key column %s not found in target model %s", rel.Relationship.TargetKey, targetModel.Name)
		}

	case "has_one", "has_many":
		if !g.hasColumn(targetModel, rel.Relationship.ForeignKey) {
			return fmt.Errorf("foreign key column %s not found in target model %s", rel.Relationship.ForeignKey, targetModel.Name)
		}
		if !g.hasColumn(model, rel.Relationship.SourceKey) {
			return fmt.Errorf("source key column %s not found in model %s", rel.Relationship.SourceKey, model.Name)
		}

	case "has_many_through":
	}

	return nil
}

func (g *CodeGenerator) hasColumn(model *ModelMetadata, columnName string) bool {
	for _, field := range model.Columns {
		if field.DBName == columnName {
			return true
		}
	}
	return false
}

func (g *CodeGenerator) GenerateForModel(modelName string) error {
	model, exists := g.models[modelName]
	if !exists {
		return fmt.Errorf("model %s not found", modelName)
	}

	if err := g.loadTemplates(); err != nil {
		return fmt.Errorf("failed to load templates: %w", err)
	}

	data := struct {
		Package string
		Model   *ModelMetadata
		Now     time.Time
	}{
		Package: g.packageName,
		Model:   model,
		Now:     time.Now(),
	}

	filename := fmt.Sprintf("%s_repository.go", toSnakeCase(model.Name))
	if err := g.executeTemplate("repository", filename, data); err != nil {
		return fmt.Errorf("failed to generate repository: %w", err)
	}

	filename = fmt.Sprintf("%s_query.go", toSnakeCase(model.Name))
	if err := g.executeTemplate("query", filename, data); err != nil {
		return fmt.Errorf("failed to generate query builder: %w", err)
	}

	return nil
}

func (g *CodeGenerator) CleanOutput() error {
	return filepath.Walk(g.outputDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if !info.IsDir() && strings.HasSuffix(path, ".go") {
			content, err := os.ReadFile(path)
			if err != nil {
				return err
			}

			if bytes.Contains(content, []byte("// Code generated by db-migrator")) {
				return os.Remove(path)
			}
		}

		return nil
	})
}

func isAutoGeneratedDefault(defaultValue string) bool {
	autoGenDefaults := []string{
		"now()", "CURRENT_TIMESTAMP", "current_timestamp",
		"gen_random_uuid()", "uuid_generate_v4()",
		"gen_cuid()", "cuid()", // CUID generation functions
		"nextval", "NEXTVAL", // for sequences
	}

	lowerDefault := strings.ToLower(defaultValue)
	for _, auto := range autoGenDefaults {
		if strings.Contains(lowerDefault, strings.ToLower(auto)) {
			return true
		}
	}
	return false
}

func sanitizeGoName(name string) string {
	goKeywords := map[string]string{
		"type":      "type_",
		"interface": "interface_",
		"struct":    "struct_",
		"func":      "func_",
		"var":       "var_",
		"const":     "const_",
		"package":   "package_",
		"import":    "import_",
		"if":        "if_",
		"else":      "else_",
		"for":       "for_",
		"while":     "while_",
		"switch":    "switch_",
		"case":      "case_",
		"default":   "default_",
		"break":     "break_",
		"continue":  "continue_",
		"return":    "return_",
		"defer":     "defer_",
		"go":        "go_",
		"chan":      "chan_",
		"select":    "select_",
		"range":     "range_",
		"map":       "map_",
		"string":    "string_",
		"int":       "int_",
		"float":     "float_",
		"bool":      "bool_",
	}

	if escaped, isKeyword := goKeywords[strings.ToLower(name)]; isKeyword {
		return escaped
	}

	return name
}
