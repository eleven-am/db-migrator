package generator

import (
	"fmt"
	"strings"
)

// SQLGenerator generates SQL DDL from database schema
type SQLGenerator struct{}

// NewSQLGenerator creates a new SQL generator
func NewSQLGenerator() *SQLGenerator {
	return &SQLGenerator{}
}

// GenerateCreateTable generates CREATE TABLE SQL for a schema table
func (g *SQLGenerator) GenerateCreateTable(table SchemaTable) string {
	var sql strings.Builder

	sql.WriteString(fmt.Sprintf("CREATE TABLE %s (\n", table.Name))

	columns := make([]string, 0, len(table.Columns))
	for _, col := range table.Columns {
		columns = append(columns, g.generateColumnDDL(col))
	}

	constraints := make([]string, 0)

	var pkColumns []string
	for _, col := range table.Columns {
		if col.IsPrimaryKey {
			pkColumns = append(pkColumns, col.Name)
		}
	}
	if len(pkColumns) > 0 {
		constraints = append(constraints, fmt.Sprintf("PRIMARY KEY (%s)", strings.Join(pkColumns, ", ")))
	}

	for _, constraint := range table.Constraints {
		switch constraint.Type {
		case "UNIQUE":
			constraints = append(constraints, fmt.Sprintf("CONSTRAINT %s UNIQUE (%s)",
				constraint.Name, strings.Join(constraint.Columns, ", ")))
		case "CHECK":
			constraints = append(constraints, fmt.Sprintf("CONSTRAINT %s CHECK (%s)",
				constraint.Name, constraint.Definition))
		case "FOREIGN KEY":
			continue
		}
	}

	allDefs := append(columns, constraints...)
	sql.WriteString("    " + strings.Join(allDefs, ",\n    "))
	sql.WriteString("\n);\n")

	for _, idx := range table.Indexes {
		if !g.isImplicitIndex(idx, table) {
			sql.WriteString("\n" + g.GenerateIndexDDL(table.Name, idx))
		}
	}

	return sql.String()
}

// generateColumnDDL generates column definition SQL
func (g *SQLGenerator) generateColumnDDL(col SchemaColumn) string {
	var parts []string

	parts = append(parts, col.Name, col.Type)

	if !col.IsNullable {
		parts = append(parts, "NOT NULL")
	}

	if col.DefaultValue != nil {
		parts = append(parts, fmt.Sprintf("DEFAULT %s", *col.DefaultValue))
	}

	if col.IsUnique && !col.IsPrimaryKey {
		parts = append(parts, "UNIQUE")
	}

	if col.ForeignKey != nil {
		parts = append(parts, fmt.Sprintf("REFERENCES %s(%s)",
			col.ForeignKey.ReferencedTable, col.ForeignKey.ReferencedColumn))

		if col.ForeignKey.OnDelete != "" && col.ForeignKey.OnDelete != "NO ACTION" {
			parts = append(parts, fmt.Sprintf("ON DELETE %s", col.ForeignKey.OnDelete))
		}
		if col.ForeignKey.OnUpdate != "" && col.ForeignKey.OnUpdate != "NO ACTION" {
			parts = append(parts, fmt.Sprintf("ON UPDATE %s", col.ForeignKey.OnUpdate))
		}
	}

	if col.CheckConstraint != nil {
		parts = append(parts, fmt.Sprintf("CHECK (%s)", *col.CheckConstraint))
	}

	return strings.Join(parts, " ")
}

// GenerateIndexDDL generates CREATE INDEX SQL
func (g *SQLGenerator) GenerateIndexDDL(tableName string, idx SchemaIndex) string {
	var sql strings.Builder

	if idx.IsUnique {
		sql.WriteString("CREATE UNIQUE INDEX ")
	} else {
		sql.WriteString("CREATE INDEX ")
	}

	sql.WriteString(idx.Name)
	sql.WriteString(" ON ")
	sql.WriteString(tableName)

	if idx.Type != "" && idx.Type != "btree" {
		sql.WriteString(" USING ")
		sql.WriteString(idx.Type)
	}

	sql.WriteString(" (")
	sql.WriteString(strings.Join(idx.Columns, ", "))
	sql.WriteString(")")

	if idx.Where != "" {
		sql.WriteString(" WHERE ")
		sql.WriteString(idx.Where)
	}

	sql.WriteString(";\n")

	return sql.String()
}

// isImplicitIndex checks if an index is created implicitly by constraints
func (g *SQLGenerator) isImplicitIndex(idx SchemaIndex, table SchemaTable) bool {
	if idx.IsPrimary {
		return true
	}

	if idx.IsUnique && len(idx.Columns) == 1 {
		for _, col := range table.Columns {
			if col.Name == idx.Columns[0] && col.IsUnique {
				return true
			}
		}
	}

	return false
}

// GenerateSchema generates CREATE statements for entire schema
func (g *SQLGenerator) GenerateSchema(schema *DatabaseSchema) string {
	var sql strings.Builder

	sql.WriteString("-- Generated by webhook-router migration tool\n")
	sql.WriteString("-- Enable required extensions\n")
	sql.WriteString("CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\n")
	sql.WriteString("CREATE EXTENSION IF NOT EXISTS \"pgcrypto\";\n\n")

	if g.schemaUsesCUIDs(schema) {
		sql.WriteString("-- CUID generation function\n")
		sql.WriteString("-- Option 1: Use pg_cuid extension if available\n")
		sql.WriteString("-- CREATE EXTENSION IF NOT EXISTS \"pg_cuid\";\n\n")
		sql.WriteString("-- Option 2: Production-ready CUID generator function\n")
		sql.WriteString("CREATE OR REPLACE FUNCTION gen_cuid() RETURNS CHAR(25) AS $$\n")
		sql.WriteString("DECLARE\n")
		sql.WriteString("    v_timestamp BIGINT;\n")
		sql.WriteString("    v_counter BIGINT;\n")
		sql.WriteString("    v_fingerprint TEXT;\n")
		sql.WriteString("    v_random TEXT;\n")
		sql.WriteString("    v_base36 TEXT := '0123456789abcdefghijklmnopqrstuvwxyz';\n")
		sql.WriteString("    v_result TEXT := 'c';\n")
		sql.WriteString("BEGIN\n")
		sql.WriteString("    v_timestamp := FLOOR(EXTRACT(EPOCH FROM clock_timestamp()) * 1000);\n")
		sql.WriteString("    \n")
		sql.WriteString("    v_counter := nextval('cuid_counter_seq');\n")
		sql.WriteString("    \n")
		sql.WriteString("    -- Handle potential NULL from inet_server_addr()\n")
		sql.WriteString("    v_fingerprint := encode(digest(current_database() || COALESCE(inet_server_addr()::TEXT, 'localhost'), 'sha256'), 'hex');\n")
		sql.WriteString("    \n")
		sql.WriteString("    v_result := v_result || lpad(to_base36(v_timestamp), 8, '0');\n")
		sql.WriteString("    \n")
		sql.WriteString("    v_result := v_result || lpad(to_base36(v_counter % 1679616), 4, '0');\n")
		sql.WriteString("    \n")
		sql.WriteString("    v_result := v_result || substr(v_fingerprint, 1, 4);\n")
		sql.WriteString("    \n")
		sql.WriteString("    v_random := encode(gen_random_bytes(6), 'hex');\n")
		sql.WriteString("    v_result := v_result || substr(v_random, 1, 8);\n")
		sql.WriteString("    \n")
		sql.WriteString("    RETURN v_result;\n")
		sql.WriteString("END;\n")
		sql.WriteString("$$ LANGUAGE plpgsql VOLATILE;\n\n")
		sql.WriteString("-- Create sequence for CUID counter if it doesn't exist\n")
		sql.WriteString("CREATE SEQUENCE IF NOT EXISTS cuid_counter_seq;\n\n")
		sql.WriteString("-- Base36 encoding function for CUID generation\n")
		sql.WriteString("CREATE OR REPLACE FUNCTION to_base36(num BIGINT) RETURNS TEXT AS $$\n")
		sql.WriteString("DECLARE\n")
		sql.WriteString("    v_base36 TEXT := '0123456789abcdefghijklmnopqrstuvwxyz';\n")
		sql.WriteString("    v_result TEXT := '';\n")
		sql.WriteString("    v_remainder INT;\n")
		sql.WriteString("BEGIN\n")
		sql.WriteString("    IF num = 0 THEN\n")
		sql.WriteString("        RETURN '0';\n")
		sql.WriteString("    END IF;\n")
		sql.WriteString("    \n")
		sql.WriteString("    WHILE num > 0 LOOP\n")
		sql.WriteString("        v_remainder := num % 36;\n")
		sql.WriteString("        v_result := substr(v_base36, v_remainder + 1, 1) || v_result;\n")
		sql.WriteString("        num := num / 36;\n")
		sql.WriteString("    END LOOP;\n")
		sql.WriteString("    \n")
		sql.WriteString("    RETURN v_result;\n")
		sql.WriteString("END;\n")
		sql.WriteString("$$ LANGUAGE plpgsql IMMUTABLE;\n\n")
	}

	tableNames := schema.GetTableNames()

	for _, tableName := range tableNames {
		table := schema.Tables[tableName]
		sql.WriteString(fmt.Sprintf("-- Table: %s\n", tableName))
		sql.WriteString(g.GenerateCreateTable(table))
		sql.WriteString("\n")
	}

	return sql.String()
}

// schemaUsesCUIDs checks if any table in the schema uses CUID type
func (g *SQLGenerator) schemaUsesCUIDs(schema *DatabaseSchema) bool {
	for _, table := range schema.Tables {
		for _, col := range table.Columns {
			colType := strings.ToUpper(col.Type)
			if strings.Contains(colType, "CUID") ||
				col.Type == "CHAR(25)" ||
				col.Type == "VARCHAR(32)" {
				return true
			}
			if col.DefaultValue != nil && strings.Contains(strings.ToLower(*col.DefaultValue), "cuid") {
				return true
			}
		}
	}
	return false
}
