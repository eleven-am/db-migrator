package migrator

import (
	"context"
	"database/sql"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"ariga.io/atlas/sql/schema"
	"github.com/eleven-am/db-migrator/internal/generator"
	"github.com/eleven-am/db-migrator/internal/parser"
)

// MigrationOptions contains options for migration generation
type MigrationOptions struct {
	PackagePath         string
	OutputDir           string
	MigrationName       string
	DryRun              bool
	AllowDestructive    bool
	PushToDB            bool
	CreateDBIfNotExists bool
}

// MigrationResult contains the results of migration generation
type MigrationResult struct {
	UpSQL          string
	DownSQL        string
	Changes        []schema.Change
	HasDestructive bool
	DestructiveOps []string
	UpFilePath     string
	DownFilePath   string
}

// AtlasMigrator handles migration generation using Atlas with simplified approach
type AtlasMigrator struct {
	config            *DBConfig
	tempDBManager     *TempDBManager
	structParser      *parser.StructParser
	schemaGenerator   *generator.SchemaGenerator
	sqlGenerator      *generator.SQLGenerator
	migrationReverser *MigrationReverser
}

// NewAtlasMigrator creates a new Atlas-based migrator
func NewAtlasMigrator(config *DBConfig) *AtlasMigrator {
	return &AtlasMigrator{
		config:            config,
		tempDBManager:     NewTempDBManager(config),
		structParser:      parser.NewStructParser(),
		schemaGenerator:   generator.NewSchemaGenerator(),
		sqlGenerator:      generator.NewSQLGenerator(),
		migrationReverser: NewMigrationReverser(),
	}
}

// GenerateMigration generates a migration from Go structs
func (m *AtlasMigrator) GenerateMigration(ctx context.Context, sourceDB *sql.DB, opts MigrationOptions) (*MigrationResult, error) {

	fmt.Println("Parsing Go structs...")
	models, err := m.structParser.ParseDirectory(opts.PackagePath)
	if err != nil {
		return nil, fmt.Errorf("failed to parse structs: %w", err)
	}
	fmt.Printf("Found %d models in %s\n", len(models), opts.PackagePath)

	fmt.Println("Generating DDL SQL from Go structs...")
	schema, err := m.schemaGenerator.GenerateSchema(models)
	if err != nil {
		return nil, fmt.Errorf("failed to generate schema: %w", err)
	}

	ddlSQL := m.sqlGenerator.GenerateSchema(schema)
	fmt.Printf("Generated DDL for %d tables\n", len(schema.Tables))

	simpleMigrator := NewSimplifiedAtlasMigrator(m.config)
	upStatements, changes, err := simpleMigrator.GenerateMigrationSimple(ctx, sourceDB, ddlSQL)
	if err != nil {
		return nil, fmt.Errorf("failed to generate migration: %w", err)
	}

	if len(changes) == 0 {
		fmt.Println("No schema changes detected! Database is up to date.")
		return &MigrationResult{}, nil
	}

	fmt.Printf("Found %d migration statements:\n", len(changes))

	destructiveCount, destructiveOps := CountDestructiveChanges(changes)

	// Step 5: Generate UP SQL
	var upBuilder strings.Builder
	upBuilder.WriteString("-- Migration UP generated by db-migrator using Atlas\n")
	upBuilder.WriteString("-- Generated at: " + time.Now().UTC().Format(time.RFC3339) + "\n\n")

	for i, stmt := range upStatements {
		upBuilder.WriteString(fmt.Sprintf("-- Statement %d: %s\n", i+1, DescribeChange(changes[i])))
		upBuilder.WriteString(stmt)
		if !strings.HasSuffix(stmt, ";") {
			upBuilder.WriteString(";")
		}
		upBuilder.WriteString("\n\n")
	}

	// Step 6: Generate DOWN SQL using reverser
	var downBuilder strings.Builder
	downBuilder.WriteString("-- Migration DOWN generated by db-migrator using Atlas\n")
	downBuilder.WriteString("-- Generated at: " + time.Now().UTC().Format(time.RFC3339) + "\n\n")
	downBuilder.WriteString("-- WARNING: Reverse migration may cause data loss!\n")
	downBuilder.WriteString("-- Review carefully before executing.\n\n")

	for i := len(upStatements) - 1; i >= 0; i-- {
		reversed, err := m.migrationReverser.ReverseSQL(upStatements[i])
		if err != nil {
			downBuilder.WriteString(fmt.Sprintf("-- ERROR: Failed to reverse statement %d: %v\n", i+1, err))
			downBuilder.WriteString(fmt.Sprintf("-- Original: %s\n\n", upStatements[i]))
		} else if reversed != "" {
			downBuilder.WriteString(fmt.Sprintf("-- Reversal of statement %d\n", i+1))
			downBuilder.WriteString(reversed)
			if !strings.HasSuffix(reversed, ";") {
				downBuilder.WriteString(";")
			}
			downBuilder.WriteString("\n\n")
		}
	}

	upSQL := upBuilder.String()
	downSQL := downBuilder.String()

	result := &MigrationResult{
		UpSQL:          upSQL,
		DownSQL:        downSQL,
		Changes:        changes,
		HasDestructive: destructiveCount > 0,
		DestructiveOps: destructiveOps,
	}

	if result.HasDestructive && !opts.AllowDestructive {
		fmt.Println("\nPOTENTIALLY DESTRUCTIVE OPERATIONS DETECTED:")
		for _, op := range destructiveOps {
			fmt.Printf("  - %s\n", op)
		}
		fmt.Println("\nUse --allow-destructive to proceed with these changes.")
		fmt.Println("Review the changes carefully as they may cause data loss.")
		return result, nil
	}

	if opts.DryRun {
		fmt.Println("\n=== UP Migration ===")
		fmt.Println(upSQL)
		fmt.Println("\n=== DOWN Migration ===")
		fmt.Println(downSQL)
		return result, nil
	}

	if opts.PushToDB {
		fmt.Println("Executing migration on database...")
		for i, stmt := range upStatements {
			fmt.Printf("Executing statement %d/%d...\n", i+1, len(upStatements))
			if _, err := sourceDB.ExecContext(ctx, stmt); err != nil {
				return nil, fmt.Errorf("failed to execute statement %d: %s\nError: %w", i+1, stmt, err)
			}
		}
		fmt.Printf("\nMigration executed successfully! Applied %d changes.\n", len(upStatements))
		return result, nil
	}

	if opts.OutputDir != "" {
		if err := m.writeMigrationFiles(opts.OutputDir, opts.MigrationName, upSQL, downSQL); err != nil {
			return nil, fmt.Errorf("failed to write migration files: %w", err)
		}

		timestamp := time.Now().UTC().Format("20060102150405")
		migrationName := opts.MigrationName
		if migrationName == "" {
			migrationName = "schema_update"
		}
		baseName := fmt.Sprintf("%s_%s", timestamp, migrationName)
		result.UpFilePath = filepath.Join(opts.OutputDir, fmt.Sprintf("%s.up.sql", baseName))
		result.DownFilePath = filepath.Join(opts.OutputDir, fmt.Sprintf("%s.down.sql", baseName))

		fmt.Printf("\nMigration files created:\n")
		fmt.Printf("  UP:   %s\n", result.UpFilePath)
		fmt.Printf("  DOWN: %s\n", result.DownFilePath)
	}

	return result, nil
}

// writeMigrationFiles writes UP and DOWN migration files
func (m *AtlasMigrator) writeMigrationFiles(outputDir, migrationName, upSQL, downSQL string) error {

	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	timestamp := time.Now().UTC().Format("20060102150405")
	if migrationName == "" {
		migrationName = "schema_update"
	}

	baseName := fmt.Sprintf("%s_%s", timestamp, migrationName)
	upFile := filepath.Join(outputDir, fmt.Sprintf("%s.up.sql", baseName))
	downFile := filepath.Join(outputDir, fmt.Sprintf("%s.down.sql", baseName))

	if err := os.WriteFile(upFile, []byte(upSQL), 0644); err != nil {
		return fmt.Errorf("failed to write UP migration: %w", err)
	}

	if err := os.WriteFile(downFile, []byte(downSQL), 0644); err != nil {
		return fmt.Errorf("failed to write DOWN migration: %w", err)
	}

	return nil
}
