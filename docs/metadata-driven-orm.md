# Metadata-Driven ORM Design

## Overview

This document outlines the design philosophy and implementation approach for Storm's metadata-driven ORM, which achieves zero-reflection operations through compile-time code generation.

## Core Philosophy

Traditional Go ORMs rely heavily on runtime reflection to:
- Discover struct fields and their tags
- Extract values from struct instances
- Map between database columns and struct fields
- Determine which fields to include in INSERT/UPDATE operations

Storm takes a different approach: **all structural knowledge is captured at compile-time** through code generation, eliminating runtime reflection entirely.

## The Problem with Reflection

```go
// Traditional ORM approach - uses reflection
func (orm *ORM) Insert(model interface{}) error {
    modelValue := reflect.ValueOf(model)
    modelType := modelValue.Type()
    
    // Runtime discovery of fields
    for i := 0; i < modelType.NumField(); i++ {
        field := modelType.Field(i)
        tag := field.Tag.Get("db")
        // ... extract value using reflection
    }
}
```

This approach has several drawbacks:
- Performance overhead from reflection
- Loss of compile-time type safety
- No IDE autocompletion or static analysis
- Runtime panics from type mismatches

## The Metadata-Driven Solution

### 1. Compile-Time Metadata Generation

The `storm-gen` tool analyzes your struct definitions and generates comprehensive metadata:

```go
var UserStormMetadata = &orm.ModelMetadata{
    TableName:  "users",
    StructName: "User",
    
    Columns: map[string]*orm.ColumnMetadata{
        "Email": {
            FieldName:       "Email",
            DBName:          "email",
            GoType:          "string",
            IsPointer:       false,
            IsAutoGenerated: false,
            
            // Generated accessor functions
            GetValue: func(model interface{}) interface{} {
                return model.(User).Email
            },
            SetValue: func(model interface{}, value interface{}) {
                model.(*User).Email = value.(string)
            },
        },
        "Name": {
            FieldName:       "Name", 
            DBName:          "name",
            GoType:          "*string",
            IsPointer:       true,
            IsAutoGenerated: false,
            
            // Pointer-aware accessors
            GetValue: func(model interface{}) interface{} {
                u := model.(User)
                if u.Name != nil {
                    return *u.Name
                }
                return nil
            },
            SetValue: func(model interface{}, value interface{}) {
                u := model.(*User)
                if value == nil {
                    u.Name = nil
                } else {
                    v := value.(string)
                    u.Name = &v
                }
            },
            IsNil: func(model interface{}) bool {
                return model.(User).Name == nil
            },
        },
        // ... more fields
    },
    
    PrimaryKeys: []string{"id"},
    
    Relationships: map[string]*orm.RelationshipMetadata{
        "Todos": {
            Name:       "Todos",
            Type:       "has_many",
            Target:     "todos",
            ForeignKey: "user_id",
            SourceKey:  "id",
            IsSlice:    true,
            
            GetValue: func(model interface{}) interface{} {
                return model.(User).Todos
            },
            SetValue: func(model interface{}, value interface{}) {
                model.(*User).Todos = value.([]Todo)
            },
        },
        "Profile": {
            Name:       "Profile",
            Type:       "has_one",
            Target:     "profiles",
            ForeignKey: "user_id",
            SourceKey:  "id",
            IsSlice:    false,
            
            GetValue: func(model interface{}) interface{} {
                return model.(User).Profile
            },
            SetValue: func(model interface{}, value interface{}) {
                model.(*User).Profile = value.(*Profile)
            },
        },
    },
}
```

### 2. Repository Initialization

Repositories are initialized with pre-generated metadata passed as a parameter:

```go
type Repository[T any] struct {
    db       DBExecutor
    metadata *ModelMetadata
}

// Generated code would create type-specific repository constructors
func NewUserRepository(db *sqlx.DB) *Repository[User] {
    return NewRepository[User](db, UserStormMetadata)
}

// Or use the generic constructor directly
userRepo := NewRepository[User](db, UserStormMetadata)
```

Models are plain structs with no interface requirements - they don't need to implement any methods.

### 3. Field Selection Logic

The repository uses metadata to implement field selection without reflection:

```go
func (r *Repository[T]) GetInsertFields(model T) (columns []string, values []interface{}) {
    for _, col := range r.metadata.Columns {
        // Skip auto-generated fields (ID, timestamps with defaults)
        if col.IsAutoGenerated {
            continue
        }
        
        // For pointer fields, skip if nil (let DB use default)
        if col.IsPointer && col.IsNil(model) {
            continue
        }
        
        // Include this field
        columns = append(columns, col.DBName)
        values = append(values, col.GetValue(model))
    }
    return
}

func (r *Repository[T]) GetUpdateFields(model T) map[string]interface{} {
    fields := make(map[string]interface{})
    
    for _, col := range r.metadata.Columns {
        // Skip primary keys and auto-generated fields
        if col.IsPrimaryKey || col.IsAutoGenerated {
            continue
        }
        
        // Include ALL fields (nil pointers become NULL)
        fields[col.DBName] = col.GetValue(model)
    }
    return fields
}
```

## Design Principles

### 1. Partial Inserts
- Only non-nil pointer fields are included in INSERT statements
- Allows database defaults to apply for omitted fields
- Non-pointer fields are always included (zero values are valid)

### 2. Full Updates  
- All non-PK, non-auto-generated fields are included in UPDATE statements
- Nil pointers are explicitly set to NULL
- Assumes the entire object has been modified

### 3. Auto-Generated Fields
- Fields marked as `IsAutoGenerated` (IDs, timestamps) are never included in INSERT/UPDATE
- The database manages these fields entirely

## Benefits

1. **Zero Runtime Reflection**: All type information is known at compile time
2. **Type Safety**: Generated code is fully typed, catching errors at compile time
3. **Performance**: Direct field access is orders of magnitude faster than reflection
4. **IDE Support**: Full autocompletion and static analysis
5. **Debugging**: Generated code is readable and debuggable

## Example Usage

```go
user := User{
    Email:    "john@example.com",
    Name:     &"John Doe",       // Pointer field with value
    Age:      nil,               // Pointer field nil - omitted from INSERT
    IsActive: true,
}

// INSERT generates:
// INSERT INTO users (email, name, is_active) VALUES ($1, $2, $3)
// Note: 'age' is omitted, 'id', 'created_at', 'updated_at' are auto-generated

// UPDATE generates:  
// UPDATE users SET email=$1, name=$2, age=$3, is_active=$4 WHERE id=$5
// Note: 'age' is included as NULL, auto-generated fields are skipped
```

## Relationship Loading

The metadata-driven approach extends seamlessly to relationships:

```go
// Generated relationship metadata includes accessor functions
"Todos": &RelationshipMetadata{
    Name:       "Todos",
    Type:       "has_many",
    Target:     "todos",
    ForeignKey: "user_id",
    SourceKey:  "id",
    IsSlice:    true,
    
    // Zero-reflection relationship access
    GetValue: func(model interface{}) interface{} {
        return model.(User).Todos
    },
    SetValue: func(model interface{}, value interface{}) {
        model.(*User).Todos = value.([]Todo)
    },
}
```

The repository loads relationships without reflection:

```go
func (q *Query[T]) loadHasManyRelationship(records []T, relMeta *RelationshipMetadata) error {
    // Load related records from database
    relatedRecords := loadFromDB(relMeta.Target, relMeta.ForeignKey, recordIDs)
    
    // Group by foreign key
    grouped := groupByForeignKey(relatedRecords, relMeta.ForeignKey)
    
    // Set relationships using generated SetValue function
    for i, record := range records {
        recordID := getRecordID(record)
        if relatedGroup, exists := grouped[recordID]; exists {
            // No reflection - uses generated function
            relMeta.SetValue(&records[i], relatedGroup)
        }
    }
    
    return nil
}
```

## Implementation Checklist

- [x] Enhance `ColumnMetadata` with function pointers for value access
  - `GetValue`: Extract field value (with pointer dereferencing)
  - `SetValue`: Set field value (handles pointer allocation)
  - `IsNil`: Check if pointer field is nil (only for pointer fields)
- [x] Enhance `RelationshipMetadata` with accessor functions
  - `GetValue`: Get current relationship value
  - `SetValue`: Set loaded relationship data
  - `IsSlice`: Track whether it's a slice relationship
- [ ] Update generator to create accessor functions for each field and relationship
- [x] Modify repository initialization to accept pre-generated metadata
- [x] Implement metadata-driven `GetInsertFields` and `GetUpdateFields`
- [ ] Update relationship loading to use metadata accessors
- [x] Remove all reflection from field value extraction
- [ ] Maintain reflection only for database result scanning (handled by `sqlx`)

## SetValue Functions

While initially omitted, `SetValue` functions are necessary for:

1. **Relationship loading** - Setting loaded relationships back onto models
2. **Custom field population** - When bypassing `sqlx` scanning
3. **Computed fields** - Setting derived values after queries

The generated `SetValue` functions handle:
- Type conversions
- Pointer field allocation
- Nil handling for optional fields

This completes the zero-reflection approach for all ORM operations except the unavoidable database result scanning in `sqlx`.

## Future Enhancements

1. **Nested Struct Support**: Extend metadata to handle embedded structs
2. **Custom Types**: Generate appropriate accessors for custom types with Scan/Value methods  
3. **Computed Fields**: Support for fields that are computed from other fields
4. **Validation Functions**: Compile-time generation of validation logic