# Metadata-Driven ORM Design

## Overview

This document outlines the design philosophy and implementation approach for Storm's metadata-driven ORM, which achieves zero-reflection operations through compile-time code generation.

## Core Philosophy

Traditional Go ORMs rely heavily on runtime reflection to:
- Discover struct fields and their tags
- Extract values from struct instances
- Map between database columns and struct fields
- Determine which fields to include in INSERT/UPDATE operations

Storm takes a different approach: **all structural knowledge is captured at compile-time** through code generation, eliminating runtime reflection entirely.

## The Problem with Reflection

```go
// Traditional ORM approach - uses reflection
func (orm *ORM) Insert(model interface{}) error {
    modelValue := reflect.ValueOf(model)
    modelType := modelValue.Type()
    
    // Runtime discovery of fields
    for i := 0; i < modelType.NumField(); i++ {
        field := modelType.Field(i)
        tag := field.Tag.Get("db")
        // ... extract value using reflection
    }
}
```

This approach has several drawbacks:
- Performance overhead from reflection
- Loss of compile-time type safety
- No IDE autocompletion or static analysis
- Runtime panics from type mismatches

## The Metadata-Driven Solution

### 1. Compile-Time Metadata Generation

The Storm ORM generator analyzes your struct definitions and generates comprehensive metadata:

```go
var UserStormMetadata = &orm.ModelMetadata{
    TableName:  "users",
    StructName: "User",
    
    // Field mappings for efficient lookups
    Columns: map[string]*orm.ColumnMetadata{
        "Email": {
            FieldName:       "Email",
            DBName:          "email",
            DBType:          "varchar(255)",
            GoType:          "string",
            IsPrimaryKey:    false,
            IsAutoGenerated: false,
            IsNullable:      false,
            IsUnique:        true,
            IsPointer:       false,
            
            // Generated accessor function for zero-reflection field access
            GetValue: func(model interface{}) interface{} {
                return model.(User).Email
            },
        },
        "Name": {
            FieldName:       "Name", 
            DBName:          "name",
            DBType:          "varchar(100)",
            GoType:          "*string",
            IsPrimaryKey:    false,
            IsAutoGenerated: false,
            IsNullable:      true,
            IsUnique:        false,
            IsPointer:       true,
            
            // Pointer-aware accessor
            GetValue: func(model interface{}) interface{} {
                u := model.(User)
                if u.Name != nil {
                    return *u.Name
                }
                return nil
            },
            IsNil: func(model interface{}) bool {
                return model.(User).Name == nil
            },
        },
        "ID": {
            FieldName:       "ID",
            DBName:          "id",
            DBType:          "uuid",
            GoType:          "string",
            IsPrimaryKey:    true,
            IsAutoGenerated: true,
            IsNullable:      false,
            IsUnique:        true,
            IsPointer:       false,
            
            GetValue: func(model interface{}) interface{} {
                return model.(User).ID
            },
        },
        // ... more fields
    },
    
    // Efficient field name mappings
    ColumnMap:  map[string]string{"Email": "email", "Name": "name", "ID": "id"},
    ReverseMap: map[string]string{"email": "Email", "name": "Name", "id": "ID"},
    
    PrimaryKeys: []string{"id"},
    
    Relationships: map[string]*orm.RelationshipMetadata{
        "Todos": {
            Name:       "Todos",
            Type:       "has_many",
            Target:     "Todo",
            ForeignKey: "user_id",
            SourceKey:  "id",
            
            // Generated function for zero-reflection relationship loading
            ScanToModel: func(ctx context.Context, exec DBExecutor, query string, args []interface{}, model interface{}) error {
                // Direct scanning into the model's Todos field
                return scanTodosIntoUser(ctx, exec, query, args, model.(*User))
            },
        },
        "Profile": {
            Name:       "Profile",
            Type:       "has_one",
            Target:     "Profile",
            ForeignKey: "user_id",
            SourceKey:  "id",
            
            ScanToModel: func(ctx context.Context, exec DBExecutor, query string, args []interface{}, model interface{}) error {
                // Direct scanning into the model's Profile field
                return scanProfileIntoUser(ctx, exec, query, args, model.(*User))
            },
        },
    },
}
```

### 2. Repository Initialization

Repositories are initialized with pre-generated metadata passed as a parameter:

```go
type Repository[T any] struct {
    db       DBExecutor
    metadata *ModelMetadata
}

// Generated code creates type-specific repository constructors
func NewUserRepository(db DBExecutor) *Repository[User] {
    return NewRepository[User](db, UserStormMetadata)
}

// Or use the generic constructor directly
userRepo := NewRepository[User](db, UserStormMetadata)
```

Models are plain structs with no interface requirements - they don't need to implement any methods.

### 3. Field Selection Logic

The repository uses metadata to implement field selection without reflection:

```go
func (r *Repository[T]) GetInsertFields(model T) (columns []string, values []interface{}) {
    for _, col := range r.metadata.Columns {
        // Skip auto-generated fields (ID, timestamps with defaults)
        if col.IsAutoGenerated {
            continue
        }
        
        // For pointer fields, skip if nil (let DB use default)
        if col.IsPointer && col.IsNil != nil && col.IsNil(model) {
            continue
        }
        
        // Include this field
        columns = append(columns, col.DBName)
        values = append(values, col.GetValue(model))
    }
    return
}

func (r *Repository[T]) GetUpdateFields(model T) map[string]interface{} {
    fields := make(map[string]interface{})
    
    for _, col := range r.metadata.Columns {
        // Skip primary keys and auto-generated fields
        if col.IsPrimaryKey || col.IsAutoGenerated {
            continue
        }
        
        // Include ALL fields (nil pointers become NULL)
        fields[col.DBName] = col.GetValue(model)
    }
    return fields
}
```

## Design Principles

### 1. Partial Inserts
- Only non-nil pointer fields are included in INSERT statements
- Allows database defaults to apply for omitted fields
- Non-pointer fields are always included (zero values are valid)

### 2. Full Updates  
- All non-PK, non-auto-generated fields are included in UPDATE statements
- Nil pointers are explicitly set to NULL
- Assumes the entire object has been modified

### 3. Auto-Generated Fields
- Fields marked as `IsAutoGenerated` (IDs, timestamps) are never included in INSERT/UPDATE
- The database manages these fields entirely

## Benefits

1. **Zero Runtime Reflection**: All type information is known at compile time
2. **Type Safety**: Generated code is fully typed, catching errors at compile time
3. **Performance**: Direct field access is orders of magnitude faster than reflection
4. **IDE Support**: Full autocompletion and static analysis
5. **Debugging**: Generated code is readable and debuggable

## Example Usage

```go
user := User{
    Email:    "john@example.com",
    Name:     &"John Doe",       // Pointer field with value
    Age:      nil,               // Pointer field nil - omitted from INSERT
    IsActive: true,
}

// INSERT generates:
// INSERT INTO users (email, name, is_active) VALUES ($1, $2, $3)
// Note: 'age' is omitted, 'id', 'created_at', 'updated_at' are auto-generated

// UPDATE generates:  
// UPDATE users SET email=$1, name=$2, age=$3, is_active=$4 WHERE id=$5
// Note: 'age' is included as NULL, auto-generated fields are skipped
```

## Relationship Loading

The metadata-driven approach extends seamlessly to relationships using the `ScanToModel` pattern:

```go
// Generated relationship metadata includes direct scanning functions
"Todos": &RelationshipMetadata{
    Name:       "Todos",
    Type:       "has_many",
    Target:     "Todo",
    ForeignKey: "user_id",
    SourceKey:  "id",
    
    // Generated function for zero-reflection relationship loading
    ScanToModel: func(ctx context.Context, exec DBExecutor, query string, args []interface{}, model interface{}) error {
        // Direct scanning into the model's Todos field
        return scanTodosIntoUser(ctx, exec, query, args, model.(*User))
    },
}
```

The repository loads relationships without reflection using the `ScanToModel` pattern:

```go
func (q *Query[T]) loadHasManyRelationship(records []T, relMeta *RelationshipMetadata) error {
    // Build query to load related records
    query := buildRelationshipQuery(relMeta, getRecordIDs(records))
    
    // Use generated ScanToModel function to load relationships directly
    for i := range records {
        err := relMeta.ScanToModel(q.ctx, q.db, query, args, &records[i])
        if err != nil {
            return err
        }
    }
    
    return nil
}
```

## Implementation Status

- [x] **Enhanced `ColumnMetadata`** with function pointers for value access
  - `GetValue`: Extract field value (with pointer dereferencing)
  - `IsNil`: Check if pointer field is nil (only for pointer fields)
  - Added comprehensive metadata fields: `DBType`, `IsNullable`, `IsUnique`, etc.
- [x] **Enhanced `RelationshipMetadata`** with direct scanning functions
  - `ScanToModel`: Direct database scanning into model relationships
  - Eliminated need for intermediate `GetValue`/`SetValue` functions
- [x] **Updated generator** to create accessor functions for each field and relationship
- [x] **Modified repository initialization** to accept pre-generated metadata
- [x] **Implemented metadata-driven** `GetInsertFields` and `GetUpdateFields`
- [x] **Updated relationship loading** to use `ScanToModel` pattern
- [x] **Removed all reflection** from field value extraction
- [x] **Maintained reflection only** for database result scanning (handled by `sqlx`)

## ScanToModel Pattern

The current implementation uses the `ScanToModel` pattern instead of separate `GetValue`/`SetValue` functions:

1. **Direct Database Scanning** - Relationships are loaded directly from database results into model fields
2. **Zero Intermediate Steps** - No need to extract, process, and set relationship data
3. **Atomic Operations** - Each relationship loading operation is self-contained
4. **Type Safety** - All operations are generated with concrete types

The generated `ScanToModel` functions handle:
- Database query execution
- Result scanning directly into model fields
- Error handling and context management
- Type-safe field assignment

This completes the zero-reflection approach for all ORM operations except the unavoidable database result scanning in `sqlx`.

## Future Enhancements

1. **Nested Struct Support**: Extend metadata to handle embedded structs
2. **Custom Types**: Generate appropriate accessors for custom types with Scan/Value methods  
3. **Computed Fields**: Support for fields that are computed from other fields
4. **Validation Functions**: Compile-time generation of validation logic