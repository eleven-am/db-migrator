package orm

import (
	"context"
	"fmt"
	"strings"

	"github.com/Masterminds/squirrel"
	"github.com/jmoiron/sqlx"
)

// UpsertOptions configures upsert behavior
type UpsertOptions struct {
	ConflictColumns []string          // Columns that define conflicts (ON CONFLICT)
	UpdateColumns   []string          // Columns to update on conflict (if empty, updates all non-conflict columns)
	UpdateExpr      map[string]string // Custom update expressions (column -> expression)
}

// BulkUpdateOptions configures bulk update behavior
type BulkUpdateOptions struct {
	UpdateColumns []string // Columns to update (if empty, updates all non-primary key columns)
	WhereColumns  []string // Columns to match on for WHERE clause (if empty, uses primary keys)
}

func (r *Repository[T]) Create(ctx context.Context, record *T) error {
	if record == nil {
		return &Error{
			Op:    "create",
			Table: r.metadata.TableName,
			Err:   fmt.Errorf("record cannot be nil"),
		}
	}

	columns, values := r.getInsertFields(*record)
	if len(columns) == 0 {
		return &Error{
			Op:    "create",
			Table: r.metadata.TableName,
			Err:   fmt.Errorf("no fields to insert"),
		}
	}

	query := squirrel.Insert(r.metadata.TableName).
		PlaceholderFormat(squirrel.Dollar).
		Columns(columns...).
		Values(values...)

	return r.executeQueryMiddleware(OpCreate, ctx, record, query, func(middlewareCtx *MiddlewareContext) error {
		finalQuery := middlewareCtx.QueryBuilder.(squirrel.InsertBuilder)

		returningCols := r.getAutoGeneratedColumns()

		sqlQuery, args, err := finalQuery.ToSql()
		if err != nil {
			return &Error{
				Op:    "create",
				Table: r.metadata.TableName,
				Err:   fmt.Errorf("failed to build query: %w", err),
			}
		}

		if len(returningCols) > 0 {
			sqlQuery += " RETURNING " + strings.Join(returningCols, ", ")
		}

		middlewareCtx.Query = sqlQuery
		middlewareCtx.Args = args

		var execErr error
		if len(returningCols) > 0 {
			if err := r.db.GetContext(ctx, record, sqlQuery, args...); err != nil {
				execErr = err
			}
		} else {
			if _, err := r.db.ExecContext(ctx, sqlQuery, args...); err != nil {
				execErr = err
			}
		}

		if execErr != nil {
			return parsePostgreSQLError(execErr, "create", r.metadata.TableName)
		}

		return nil
	})
}

func (r *Repository[T]) FindByID(ctx context.Context, id interface{}) (*T, error) {
	if len(r.metadata.PrimaryKeys) != 1 {
		return nil, &Error{
			Op:    "findByID",
			Table: r.metadata.TableName,
			Err:   fmt.Errorf("composite primary keys not supported"),
		}
	}

	selectColumns := make([]string, 0, len(r.metadata.Columns))
	for _, col := range r.metadata.Columns {
		selectColumns = append(selectColumns, col.DBName)
	}

	query := squirrel.Select(selectColumns...).
		From(r.metadata.TableName).
		Where(squirrel.Eq{r.metadata.PrimaryKeys[0]: id}).
		PlaceholderFormat(squirrel.Dollar).
		Limit(1)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, &Error{
			Op:    "findByID",
			Table: r.metadata.TableName,
			Err:   fmt.Errorf("failed to build query: %w", err),
		}
	}

	var record T
	err = r.db.GetContext(ctx, &record, sqlQuery, args...)
	if err != nil {
		return nil, parsePostgreSQLError(err, "findByID", r.metadata.TableName)
	}

	return &record, nil
}

func (r *Repository[T]) Update(ctx context.Context, record *T) error {
	if record == nil {
		return &Error{
			Op:    "update",
			Table: r.metadata.TableName,
			Err:   fmt.Errorf("record cannot be nil"),
		}
	}

	query := squirrel.Update(r.metadata.TableName).
		PlaceholderFormat(squirrel.Dollar)

	updateFields := r.getUpdateFields(*record)
	for column, value := range updateFields {
		query = query.Set(column, value)
	}

	pkValues := r.getPrimaryKeyValues(*record)
	for pkCol, value := range pkValues {
		query = query.Where(squirrel.Eq{pkCol: value})
	}

	return r.executeQueryMiddleware(OpUpdate, ctx, record, query, func(middlewareCtx *MiddlewareContext) error {
		finalQuery := middlewareCtx.QueryBuilder.(squirrel.UpdateBuilder)

		sqlQuery, args, err := finalQuery.ToSql()
		if err != nil {
			return &Error{
				Op:    "update",
				Table: r.metadata.TableName,
				Err:   fmt.Errorf("failed to build query: %w", err),
			}
		}

		middlewareCtx.Query = sqlQuery
		middlewareCtx.Args = args

		result, err := r.db.ExecContext(ctx, sqlQuery, args...)
		if err != nil {
			return parsePostgreSQLError(err, "update", r.metadata.TableName)
		}

		rowsAffected, err := result.RowsAffected()
		if err != nil {
			return &Error{
				Op:    "update",
				Table: r.metadata.TableName,
				Err:   fmt.Errorf("failed to get rows affected: %w", err),
			}
		}

		if rowsAffected == 0 {
			return ErrNotFound
		}

		return nil
	})
}

func (r *Repository[T]) Delete(ctx context.Context, id interface{}) error {
	if len(r.metadata.PrimaryKeys) != 1 {
		return &Error{
			Op:    "delete",
			Table: r.metadata.TableName,
			Err:   fmt.Errorf("composite primary keys not supported"),
		}
	}

	query := squirrel.Delete(r.metadata.TableName).
		Where(squirrel.Eq{r.metadata.PrimaryKeys[0]: id}).
		PlaceholderFormat(squirrel.Dollar)

	return r.executeQueryMiddleware(OpDelete, ctx, id, query, func(middlewareCtx *MiddlewareContext) error {
		finalQuery := middlewareCtx.QueryBuilder.(squirrel.DeleteBuilder)

		sqlQuery, args, err := finalQuery.ToSql()
		if err != nil {
			return &Error{
				Op:    "delete",
				Table: r.metadata.TableName,
				Err:   fmt.Errorf("failed to build query: %w", err),
			}
		}

		middlewareCtx.Query = sqlQuery
		middlewareCtx.Args = args

		result, err := r.db.ExecContext(ctx, sqlQuery, args...)
		if err != nil {
			return parsePostgreSQLError(err, "delete", r.metadata.TableName)
		}

		rowsAffected, err := result.RowsAffected()
		if err != nil {
			return &Error{
				Op:    "delete",
				Table: r.metadata.TableName,
				Err:   fmt.Errorf("failed to get rows affected: %w", err),
			}
		}

		if rowsAffected == 0 {
			return ErrNotFound
		}

		return nil
	})
}

func (r *Repository[T]) DeleteRecord(ctx context.Context, record *T) error {
	if record == nil {
		return &Error{
			Op:    "deleteRecord",
			Table: r.metadata.TableName,
			Err:   fmt.Errorf("record cannot be nil"),
		}
	}

	query := squirrel.Delete(r.metadata.TableName).
		PlaceholderFormat(squirrel.Dollar)

	pkValues := r.getPrimaryKeyValues(*record)
	for pkCol, value := range pkValues {
		query = query.Where(squirrel.Eq{pkCol: value})
	}

	return r.executeQueryMiddleware(OpDelete, ctx, record, query, func(middlewareCtx *MiddlewareContext) error {
		finalQuery := middlewareCtx.QueryBuilder.(squirrel.DeleteBuilder)

		sqlQuery, args, err := finalQuery.ToSql()
		if err != nil {
			return &Error{
				Op:    "deleteRecord",
				Table: r.metadata.TableName,
				Err:   fmt.Errorf("failed to build query: %w", err),
			}
		}

		middlewareCtx.Query = sqlQuery
		middlewareCtx.Args = args

		result, err := r.db.ExecContext(ctx, sqlQuery, args...)
		if err != nil {
			return parsePostgreSQLError(err, "deleteRecord", r.metadata.TableName)
		}

		rowsAffected, err := result.RowsAffected()
		if err != nil {
			return &Error{
				Op:    "deleteRecord",
				Table: r.metadata.TableName,
				Err:   fmt.Errorf("failed to get rows affected: %w", err),
			}
		}

		if rowsAffected == 0 {
			return ErrNotFound
		}

		return nil
	})
}

func (r *Repository[T]) CreateMany(ctx context.Context, records []*T) error {
	if len(records) == 0 {
		return nil
	}

	var executor DBExecutor
	needsCommit := false

	if _, isTransaction := r.db.(*sqlx.Tx); isTransaction {
		executor = r.db
	} else {
		db := r.db.(*sqlx.DB)
		tx, err := db.BeginTxx(ctx, nil)
		if err != nil {
			return &Error{
				Op:    "createMany",
				Table: r.metadata.TableName,
				Err:   fmt.Errorf("failed to begin transaction: %w", err),
			}
		}
		defer tx.Rollback()
		executor = tx
		needsCommit = true
	}

	var columns []string
	for _, record := range records {
		if record != nil {
			columns, _ = r.getInsertFields(*record)
			break
		}
	}

	if len(columns) == 0 {
		return nil
	}

	query := squirrel.Insert(r.metadata.TableName).
		PlaceholderFormat(squirrel.Dollar).
		Columns(columns...)

	for _, record := range records {
		if record == nil {
			continue
		}

		_, values := r.getInsertFields(*record)
		query = query.Values(values...)
	}

	return r.executeQueryMiddleware(OpCreateMany, ctx, records, query, func(middlewareCtx *MiddlewareContext) error {
		finalQuery := middlewareCtx.QueryBuilder.(squirrel.InsertBuilder)

		sqlQuery, args, err := finalQuery.ToSql()
		if err != nil {
			return &Error{
				Op:    "createMany",
				Table: r.metadata.TableName,
				Err:   fmt.Errorf("failed to build batch insert query: %w", err),
			}
		}

		middlewareCtx.Query = sqlQuery
		middlewareCtx.Args = args

		_, err = executor.ExecContext(ctx, sqlQuery, args...)
		if err != nil {
			return parsePostgreSQLError(err, "createMany", r.metadata.TableName)
		}

		if needsCommit {
			tx := executor.(*sqlx.Tx)
			if err := tx.Commit(); err != nil {
				return &Error{
					Op:    "createMany",
					Table: r.metadata.TableName,
					Err:   fmt.Errorf("failed to commit transaction: %w", err),
				}
			}
		}

		return nil
	})
}

func (r *Repository[T]) Upsert(ctx context.Context, record *T, opts UpsertOptions) error {
	if record == nil {
		return &Error{
			Op:    "upsert",
			Table: r.metadata.TableName,
			Err:   fmt.Errorf("record cannot be nil"),
		}
	}

	if len(opts.ConflictColumns) == 0 {
		return &Error{
			Op:    "upsert",
			Table: r.metadata.TableName,
			Err:   fmt.Errorf("conflict columns must be specified"),
		}
	}

	columns, values := r.getInsertFields(*record)
	if len(columns) == 0 {
		return &Error{
			Op:    "upsert",
			Table: r.metadata.TableName,
			Err:   fmt.Errorf("no fields to insert"),
		}
	}

	query := squirrel.Insert(r.metadata.TableName).
		PlaceholderFormat(squirrel.Dollar).
		Columns(columns...).
		Values(values...)

	return r.executeQueryMiddleware(OpUpsert, ctx, record, query, func(middlewareCtx *MiddlewareContext) error {
		finalQuery := middlewareCtx.QueryBuilder.(squirrel.InsertBuilder)

		sqlQuery, args, err := finalQuery.ToSql()
		if err != nil {
			return &Error{
				Op:    "upsert",
				Table: r.metadata.TableName,
				Err:   fmt.Errorf("failed to build insert query: %w", err),
			}
		}

		onConflict := fmt.Sprintf(" ON CONFLICT (%s)", strings.Join(opts.ConflictColumns, ", "))

		var updateColumns []string
		if len(opts.UpdateColumns) > 0 {
			updateColumns = opts.UpdateColumns
		} else {
			conflictSet := make(map[string]bool)
			for _, col := range opts.ConflictColumns {
				conflictSet[col] = true
			}

			for _, col := range columns {
				if !conflictSet[col] {
					updateColumns = append(updateColumns, col)
				}
			}
		}

		if len(updateColumns) > 0 {
			var setParts []string
			for _, col := range updateColumns {
				if expr, hasCustom := opts.UpdateExpr[col]; hasCustom {
					setParts = append(setParts, fmt.Sprintf("%s = %s", col, expr))
				} else {
					setParts = append(setParts, fmt.Sprintf("%s = EXCLUDED.%s", col, col))
				}
			}
			onConflict += " DO UPDATE SET " + strings.Join(setParts, ", ")
		} else {
			onConflict += " DO NOTHING"
		}

		finalSqlQuery := sqlQuery + onConflict

		middlewareCtx.Query = finalSqlQuery
		middlewareCtx.Args = args

		_, err = r.db.ExecContext(ctx, finalSqlQuery, args...)
		if err != nil {
			return parsePostgreSQLError(err, "upsert", r.metadata.TableName)
		}

		return nil
	})
}

func (r *Repository[T]) UpsertMany(ctx context.Context, records []T, opts UpsertOptions) error {
	if len(records) == 0 {
		return nil
	}

	if len(opts.ConflictColumns) == 0 {
		return &Error{
			Op:    "upsertMany",
			Table: r.metadata.TableName,
			Err:   fmt.Errorf("conflict columns must be specified"),
		}
	}

	var executor DBExecutor
	needsCommit := false

	if _, isTransaction := r.db.(*sqlx.Tx); isTransaction {
		executor = r.db
	} else {
		db := r.db.(*sqlx.DB)
		tx, err := db.BeginTxx(ctx, nil)
		if err != nil {
			return &Error{
				Op:    "upsertMany",
				Table: r.metadata.TableName,
				Err:   fmt.Errorf("failed to begin transaction: %w", err),
			}
		}
		defer tx.Rollback()
		executor = tx
		needsCommit = true
	}

	var columns []string
	if len(records) > 0 {
		columns, _ = r.getInsertFields(records[0])
	}

	if len(columns) == 0 {
		return nil
	}

	query := squirrel.Insert(r.metadata.TableName).
		PlaceholderFormat(squirrel.Dollar).
		Columns(columns...)

	for _, record := range records {
		_, values := r.getInsertFields(record)
		query = query.Values(values...)
	}

	return r.executeQueryMiddleware(OpUpsertMany, ctx, records, query, func(middlewareCtx *MiddlewareContext) error {
		finalQuery := middlewareCtx.QueryBuilder.(squirrel.InsertBuilder)

		sqlQuery, args, err := finalQuery.ToSql()
		if err != nil {
			return &Error{
				Op:    "upsertMany",
				Table: r.metadata.TableName,
				Err:   fmt.Errorf("failed to build batch insert query: %w", err),
			}
		}

		onConflict := fmt.Sprintf(" ON CONFLICT (%s)", strings.Join(opts.ConflictColumns, ", "))
		var updateColumns []string
		if len(opts.UpdateColumns) > 0 {
			updateColumns = opts.UpdateColumns
		} else {
			conflictSet := make(map[string]bool)
			for _, col := range opts.ConflictColumns {
				conflictSet[col] = true
			}

			for _, col := range columns {
				if !conflictSet[col] {
					updateColumns = append(updateColumns, col)
				}
			}
		}

		if len(updateColumns) > 0 {
			var setParts []string
			for _, col := range updateColumns {
				if expr, hasCustom := opts.UpdateExpr[col]; hasCustom {
					setParts = append(setParts, fmt.Sprintf("%s = %s", col, expr))
				} else {
					setParts = append(setParts, fmt.Sprintf("%s = EXCLUDED.%s", col, col))
				}
			}
			onConflict += " DO UPDATE SET " + strings.Join(setParts, ", ")
		} else {
			onConflict += " DO NOTHING"
		}

		finalSqlQuery := sqlQuery + onConflict

		middlewareCtx.Query = finalSqlQuery
		middlewareCtx.Args = args

		_, err = executor.ExecContext(ctx, finalSqlQuery, args...)
		if err != nil {
			return parsePostgreSQLError(err, "upsertMany", r.metadata.TableName)
		}

		if needsCommit {
			tx := executor.(*sqlx.Tx)
			if err := tx.Commit(); err != nil {
				return &Error{
					Op:    "upsertMany",
					Table: r.metadata.TableName,
					Err:   fmt.Errorf("failed to commit transaction: %w", err),
				}
			}
		}

		return nil
	})
}

func (r *Repository[T]) BulkUpdate(ctx context.Context, records []T, opts BulkUpdateOptions) (int64, error) {
	if len(records) == 0 {
		return 0, nil
	}

	updateColumns := opts.UpdateColumns
	if len(updateColumns) == 0 {
		if len(records) > 0 {
			updateFields := r.getUpdateFields(records[0])
			for col := range updateFields {
				updateColumns = append(updateColumns, col)
			}
		}
	}

	whereColumns := opts.WhereColumns
	if len(whereColumns) == 0 {
		whereColumns = r.metadata.PrimaryKeys
	}

	if len(whereColumns) == 0 {
		return 0, &Error{
			Op:    "bulkUpdate",
			Table: r.metadata.TableName,
			Err:   fmt.Errorf("no where columns specified and no primary keys found"),
		}
	}

	var executor DBExecutor
	needsCommit := false
	if _, isTransaction := r.db.(*sqlx.Tx); isTransaction {
		executor = r.db
	} else {
		db := r.db.(*sqlx.DB)
		tx, err := db.BeginTxx(ctx, nil)
		if err != nil {
			return 0, &Error{
				Op:    "bulkUpdate",
				Table: r.metadata.TableName,
				Err:   fmt.Errorf("failed to begin transaction: %w", err),
			}
		}
		defer tx.Rollback()
		executor = tx
		needsCommit = true
	}

	var valueParts []string
	var args []interface{}
	argIndex := 1

	allColumns := append(whereColumns, updateColumns...)

	for _, record := range records {
		var rowValues []string
		for _, column := range allColumns {
			fieldName := r.metadata.ReverseMap[column]
			if colMeta, exists := r.metadata.Columns[fieldName]; exists && colMeta.GetValue != nil {
				value := colMeta.GetValue(record)
				if value != nil {
					rowValues = append(rowValues, fmt.Sprintf("$%d", argIndex))
					args = append(args, value)
					argIndex++
				} else {
					rowValues = append(rowValues, "NULL")
				}
			} else {
				rowValues = append(rowValues, "NULL")
			}
		}

		valueParts = append(valueParts, "("+strings.Join(rowValues, ", ")+")")
	}

	if len(valueParts) == 0 {
		return 0, nil
	}

	cteQuery := fmt.Sprintf(`
		WITH updates(%s) AS (
			VALUES %s
		)
		UPDATE %s 
		SET %s
		FROM updates
		WHERE %s`,
		strings.Join(allColumns, ", "),
		strings.Join(valueParts, ", "),
		r.metadata.TableName,
		r.buildUpdateSetClause(updateColumns, whereColumns),
		r.buildWhereClause(whereColumns),
	)

	var rowsAffected int64
	err := r.executeQueryMiddleware(OpBulkUpdate, ctx, records, squirrel.Update(r.metadata.TableName), func(middlewareCtx *MiddlewareContext) error {
		middlewareCtx.Query = cteQuery
		middlewareCtx.Args = args

		result, err := executor.ExecContext(ctx, cteQuery, args...)
		if err != nil {
			return parsePostgreSQLError(err, "bulkUpdate", r.metadata.TableName)
		}

		rowsAffected, err = result.RowsAffected()
		if err != nil {
			return &Error{
				Op:    "bulkUpdate",
				Table: r.metadata.TableName,
				Err:   fmt.Errorf("failed to get rows affected: %w", err),
			}
		}

		if needsCommit {
			tx := executor.(*sqlx.Tx)
			if err := tx.Commit(); err != nil {
				return &Error{
					Op:    "bulkUpdate",
					Table: r.metadata.TableName,
					Err:   fmt.Errorf("failed to commit transaction: %w", err),
				}
			}
		}

		return nil
	})

	return rowsAffected, err
}

func (r *Repository[T]) buildUpdateSetClause(updateColumns, whereColumns []string) string {
	var setParts []string
	for _, col := range updateColumns {
		setParts = append(setParts, fmt.Sprintf("%s = updates.%s", col, col))
	}
	return strings.Join(setParts, ", ")
}

func (r *Repository[T]) buildWhereClause(whereColumns []string) string {
	var whereParts []string
	for _, col := range whereColumns {
		whereParts = append(whereParts, fmt.Sprintf("%s.%s = updates.%s", r.metadata.TableName, col, col))
	}
	return strings.Join(whereParts, " AND ")
}
