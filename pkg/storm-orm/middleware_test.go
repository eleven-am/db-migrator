package orm

import (
	"context"
	"fmt"
	"testing"
	"time"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/Masterminds/squirrel"
	"github.com/jmoiron/sqlx"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// Test model for middleware tests
type TestUser struct {
	ID        int       `storm:"primary_key,auto_increment" db:"id"`
	Name      string    `storm:"column:name" db:"name"`
	Email     string    `storm:"column:email,unique" db:"email"`
	IsActive  bool      `storm:"column:is_active" db:"is_active"`
	CreatedAt time.Time `storm:"column:created_at,default:now()" db:"created_at"`
	UpdatedAt time.Time `storm:"column:updated_at,default:now()" db:"updated_at"`
}

// Create test metadata for TestUser
func createTestUserMetadata() *ModelMetadata {
	return &ModelMetadata{
		TableName:  "users",
		StructName: "TestUser",
		Columns: map[string]*ColumnMetadata{
			"ID": {
				FieldName:       "ID",
				DBName:          "id",
				GoType:          "int",
				IsPrimaryKey:    true,
				IsAutoGenerated: true,
				GetValue: func(model interface{}) interface{} {
					return model.(TestUser).ID
				},
			},
			"Name": {
				FieldName: "Name",
				DBName:    "name",
				GoType:    "string",
				GetValue: func(model interface{}) interface{} {
					return model.(TestUser).Name
				},
			},
			"Email": {
				FieldName: "Email",
				DBName:    "email",
				GoType:    "string",
				IsUnique:  true,
				GetValue: func(model interface{}) interface{} {
					return model.(TestUser).Email
				},
			},
			"IsActive": {
				FieldName: "IsActive",
				DBName:    "is_active",
				GoType:    "bool",
				GetValue: func(model interface{}) interface{} {
					return model.(TestUser).IsActive
				},
			},
			"CreatedAt": {
				FieldName:       "CreatedAt",
				DBName:          "created_at",
				GoType:          "time.Time",
				IsAutoGenerated: true,
				GetValue: func(model interface{}) interface{} {
					return model.(TestUser).CreatedAt
				},
			},
			"UpdatedAt": {
				FieldName:       "UpdatedAt",
				DBName:          "updated_at",
				GoType:          "time.Time",
				IsAutoGenerated: true,
				GetValue: func(model interface{}) interface{} {
					return model.(TestUser).UpdatedAt
				},
			},
		},
		ColumnMap: map[string]string{
			"ID":        "id",
			"Name":      "name",
			"Email":     "email",
			"IsActive":  "is_active",
			"CreatedAt": "created_at",
			"UpdatedAt": "updated_at",
		},
		ReverseMap: map[string]string{
			"id":         "ID",
			"name":       "Name",
			"email":      "Email",
			"is_active":  "IsActive",
			"created_at": "CreatedAt",
			"updated_at": "UpdatedAt",
		},
		PrimaryKeys: []string{"id"},
	}
}

// TestMiddlewareUpdateFields tests middleware for UpdateFields operations
func TestMiddlewareUpdateFields(t *testing.T) {
	db, mock, err := sqlmock.New()
	require.NoError(t, err)
	defer db.Close()

	sqlxDB := sqlx.NewDb(db, "postgres")
	metadata := createTestUserMetadata()

	repo, err := NewRepository[TestUser](sqlxDB, metadata)
	require.NoError(t, err)

	// Add middleware that modifies the update
	repo.AddMiddleware(func(next QueryMiddlewareFunc) QueryMiddlewareFunc {
		return func(ctx *MiddlewareContext) error {
			if ctx.Operation == OpUpdate {
				if updateBuilder, ok := ctx.QueryBuilder.(squirrel.UpdateBuilder); ok {
					// Add additional field to update
					ctx.QueryBuilder = updateBuilder.Set("updated_by", "middleware")
				}
			}
			return next(ctx)
		}
	})

	userID := 1
	now := time.Now()
	updates := map[string]interface{}{
		"name": "Updated Name",
	}

	// Set up mock expectations
	// First expect FindByID
	mock.ExpectQuery(`SELECT .* FROM users WHERE id = \$1`).
		WithArgs(userID).
		WillReturnRows(sqlmock.NewRows([]string{"id", "name", "email", "is_active", "created_at", "updated_at"}).
			AddRow(userID, "Old Name", "old@example.com", true, now, now))

	// Then expect UPDATE with additional field from middleware
	mock.ExpectExec(`UPDATE users SET`).
		WithArgs("Updated Name", "middleware", userID).
		WillReturnResult(sqlmock.NewResult(0, 1))

	// Then expect another FindByID
	mock.ExpectQuery(`SELECT .* FROM users WHERE id = \$1`).
		WithArgs(userID).
		WillReturnRows(sqlmock.NewRows([]string{"id", "name", "email", "is_active", "created_at", "updated_at"}).
			AddRow(userID, "Updated Name", "old@example.com", true, now, now))

	// Execute UpdateFields
	user, err := repo.UpdateFields(context.Background(), userID, updates)
	require.NoError(t, err)
	require.NotNil(t, user)

	// Verify all expectations were met
	require.NoError(t, mock.ExpectationsWereMet())
}

// TestMiddlewareDelete tests middleware for Delete operations
func TestMiddlewareDelete(t *testing.T) {
	db, mock, err := sqlmock.New()
	require.NoError(t, err)
	defer db.Close()

	sqlxDB := sqlx.NewDb(db, "postgres")
	metadata := createTestUserMetadata()

	repo, err := NewRepository[TestUser](sqlxDB, metadata)
	require.NoError(t, err)

	// Add middleware that prevents deletion by returning an error
	repo.AddMiddleware(func(next QueryMiddlewareFunc) QueryMiddlewareFunc {
		return func(ctx *MiddlewareContext) error {
			if ctx.Operation == OpDelete {
				// Simulate authorization check
				return fmt.Errorf("deletion not allowed")
			}
			return next(ctx)
		}
	})

	// No SQL should be executed due to middleware blocking
	_, err = repo.Delete(context.Background(), 1)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "deletion not allowed")

	// Verify no SQL was executed
	require.NoError(t, mock.ExpectationsWereMet())
}

// TestMiddlewareErrorHandling tests error handling in middleware
func TestMiddlewareErrorHandling(t *testing.T) {
	db, mock, err := sqlmock.New()
	require.NoError(t, err)
	defer db.Close()

	sqlxDB := sqlx.NewDb(db, "postgres")
	metadata := createTestUserMetadata()

	repo, err := NewRepository[TestUser](sqlxDB, metadata)
	require.NoError(t, err)

	// Add middleware that returns an error
	repo.AddMiddleware(func(next QueryMiddlewareFunc) QueryMiddlewareFunc {
		return func(ctx *MiddlewareContext) error {
			if ctx.Operation == OpCreate {
				return fmt.Errorf("create operation blocked by middleware")
			}
			return next(ctx)
		}
	})

	// Try to create - should fail
	user := &TestUser{Name: "Test", Email: "test@example.com"}
	_, err = repo.Create(context.Background(), user)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "create operation blocked by middleware")

	// Verify no SQL was executed
	require.NoError(t, mock.ExpectationsWereMet())
}

// TestMiddlewareCount tests middleware for Count operations with flexible SQL matching
func TestMiddlewareCount(t *testing.T) {
	db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherFunc(func(expectedSQL, actualSQL string) error {
		// Just verify that both conditions are present
		assert.Contains(t, actualSQL, "is_active")
		assert.Contains(t, actualSQL, "tenant_id")
		assert.Contains(t, actualSQL, "COUNT(*)")
		return nil
	})))
	require.NoError(t, err)
	defer db.Close()

	sqlxDB := sqlx.NewDb(db, "postgres")
	metadata := createTestUserMetadata()

	repo, err := NewRepository[TestUser](sqlxDB, metadata)
	require.NoError(t, err)

	// Add middleware that adds filtering
	repo.AddMiddleware(func(next QueryMiddlewareFunc) QueryMiddlewareFunc {
		return func(ctx *MiddlewareContext) error {
			if ctx.Operation == OpQuery {
				if selectBuilder, ok := ctx.QueryBuilder.(squirrel.SelectBuilder); ok {
					// Add tenant filtering
					ctx.QueryBuilder = selectBuilder.Where(squirrel.Eq{"tenant_id": 123})
				}
			}
			return next(ctx)
		}
	})

	// Set up mock expectations
	mock.ExpectQuery("SELECT COUNT").
		WillReturnRows(sqlmock.NewRows([]string{"count"}).AddRow(5))

	// Execute count
	activeCol := Column[bool]{Name: "is_active", Table: "users"}
	query := repo.Query(context.Background()).Where(activeCol.Eq(true))
	count, err := query.Count()
	require.NoError(t, err)
	assert.Equal(t, int64(5), count)

	// Verify all expectations were met
	require.NoError(t, mock.ExpectationsWereMet())
}

// TestMiddlewareUpdateMany tests middleware for UpdateMany operations with flexible SQL matching
func TestMiddlewareUpdateMany(t *testing.T) {
	db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherFunc(func(expectedSQL, actualSQL string) error {
		// Just verify that the tenant condition was added
		assert.Contains(t, actualSQL, "tenant_id")
		assert.Contains(t, actualSQL, "UPDATE users")
		assert.Contains(t, actualSQL, "is_active")
		return nil
	})))
	require.NoError(t, err)
	defer db.Close()

	sqlxDB := sqlx.NewDb(db, "postgres")
	metadata := createTestUserMetadata()

	repo, err := NewRepository[TestUser](sqlxDB, metadata)
	require.NoError(t, err)

	// Add middleware that adds tenant filtering
	repo.AddMiddleware(func(next QueryMiddlewareFunc) QueryMiddlewareFunc {
		return func(ctx *MiddlewareContext) error {
			if ctx.Operation == OpUpdateMany {
				if updateBuilder, ok := ctx.QueryBuilder.(squirrel.UpdateBuilder); ok {
					// Add tenant condition
					ctx.QueryBuilder = updateBuilder.Where(squirrel.Eq{"tenant_id": 123})
				}
			}
			return next(ctx)
		}
	})

	// Set up mock expectations
	mock.ExpectExec("UPDATE users").
		WillReturnResult(sqlmock.NewResult(0, 3))

	// Execute update many
	updates := map[string]interface{}{
		"is_active": false,
	}
	nameCol := StringColumn{Column: Column[string]{Name: "name", Table: "users"}}
	condition := nameCol.Like("test%")
	rowsAffected, err := repo.Query(context.Background()).Where(condition).Update(updates)
	require.NoError(t, err)
	assert.Equal(t, int64(3), rowsAffected)

	// Verify all expectations were met
	require.NoError(t, mock.ExpectationsWereMet())
}
